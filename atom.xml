<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>Cinode dev blog</title>
 <link href="http://cinode.github.io/atom.xml" rel="self"/>
 <link href="http://cinode.github.io"/>
 <updated>2016-06-22T09:47:03+02:00</updated>
 <id>http://cinode.github.io</id>
 <author>
   <name>BYO</name>
   <email></email>
 </author>

 
 <entry>
   <title>Password please</title>
   <link href="http://cinode.github.io/2016/06/18/password-please"/>
   <updated>2016-06-18T00:00:00+02:00</updated>
   <id>http://cinode.github.io/2016/06/18/password-please</id>
   <content type="html">
&lt;h1 id=&quot;good-keys-bad-keys&quot;&gt;Good Keys, bad keys&lt;/h1&gt;

&lt;p&gt;When using encryption, good
&lt;a href=&quot;https://en.wikipedia.org/wiki/Key_(cryptography)&quot;&gt;encryption keys&lt;/a&gt; are
essential. They must be generated randomly and must contain enough entropy.
Otherwise we’ll open wide range of attacks on encrypted data.
In addition to the key, we also need
&lt;a href=&quot;https://en.wikipedia.org/wiki/Initialization_vector&quot;&gt;Initialization Vector&lt;/a&gt;
(IV) which doesn’t necessarily have to be secret, but still it should be either
pseudorandom or (in case of some encryption primitives) just unique when used
together with the same key (IV is then also called a nonce).&lt;/p&gt;

&lt;p&gt;We would like to apply encryption to our data blobs. Just to briefly recall,
our blobs are static, can not chagnge. Every blob has it’s own uinque name.
This name is made of cryptographically secure hash of blob’s data. This
hash also guarantees integrity of the information.&lt;/p&gt;

&lt;h1 id=&quot;randomize-everything&quot;&gt;Randomize everything&lt;/h1&gt;

&lt;p&gt;So, what would be the most trivial way of generating keys and IV.&lt;/p&gt;

&lt;p&gt;If keys should be random, and random IVs are also a good choice, why not just
randomly generate key for every blob? For AES-256 we would have to generate
more than 2^128 blobs (due to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Birthday_problem&quot;&gt;birthday paradox&lt;/a&gt;) to reuse key
with probbility of ~0.5, so even if we use always the same IV and nonce-based
encryption primitives, we’re still pretty safe.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/ditaa/ditaa-df68088d2039fef59a2cff9f19bca0337573fba8.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;What would be properties of such solution:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Every blob has unique key&lt;/li&gt;
  &lt;li&gt;IV can be hardcoded for nonce-based encryption modes since we’re changing
key for every blob&lt;/li&gt;
  &lt;li&gt;One blob encrypted twice will generate different key and different encrypted
blob&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All those properties may be both advantages and disadvantages.
Uniqueness of the key does guarantee high security but would require management
of such keys and won’t let us initilize the cipher once and reuse for multiple
blobs.&lt;/p&gt;

&lt;p&gt;Let’s take a look at the fact that reencryption will use different key - one
benefit of this approach is that if two
people encrypt the same data, keys will be different and the encrypted blob data
will be different too. The only thing equal would be the size of blob (which
can be handled by some clever splitting and merging of data). Overall this could
look like a good solution. But it has one drawback - it does take away
deduplication which is natural in case of CAS systems. We could argue that
it’s not that needed and I agree. But in case you would be uploading your own files,
finding duplicates could would be useful. Also in case of public data or data
shared among many peole it’s better to have same keys for same blobs. This would
reduce unnecesary duplicates of data and help reducing maintenance costs - less
data to manage is always easier to manage and scale.&lt;/p&gt;

&lt;h1 id=&quot;derived-deterministic-keys&quot;&gt;Derived Deterministic keys&lt;/h1&gt;

&lt;p&gt;Ok, let’s try the opposite side - let’s try to assign a key to a blob in such
way that each key can be unambigously assigned to it’s blob.&lt;/p&gt;

&lt;p&gt;Key must be random. One way to build pseudorandom number generator is to &lt;a href=&quot;https://en.wikipedia.org/wiki/Cryptographic_hash_function#Use_in_building_other_cryptographic_primitives&quot;&gt;use
cryptographic hash&lt;/a&gt;,
because cryptographic hash function should behave similarly to random function.
So why not just use the hash of blobs contents and use this hash as a key?
IV could be handled as before. For every blob we still use different key
so similarly to just random keys we can use predefined one for all our
cases (as long as we’re using nonce-based encryption primitives of course).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/ditaa/ditaa-606f3b2a8b9e82e6a384b1e7c0f5d2f2be2e3cee.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;What properties would we get here:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Every blob has unique key&lt;/li&gt;
  &lt;li&gt;IV can be hardcoded for nonce-based encryption modes since we’re changing
key for every blob&lt;/li&gt;
  &lt;li&gt;Every blob of data will have exactly one key assigned and same representation
of encrypted data&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;First two points are equal to the previous case. The third one is the
opposite so let’s take a closer look.&lt;/p&gt;

&lt;p&gt;Now we are able to introduce global deduplication mechanism. If two people upload
same data to one CAS, those uploads would be identical. Such blobs would share
keys, IVs and encrypted representation. This could mean significant reduction
of space usage and may significantly reduce network costs. But it does reveal an
extra information to external observer. If the observer finds out that Alice and
Bob uploaded same blob, he would be able to assume that they have access to same
peace of unencrypted information. In case Alice does protect her environment well
and is able to fight off all attacks, attacker may also try to attack Bob. If
Bob is not that good protecting himself, the attacker may gain plain data that
was shared between Alice nad Bob.&lt;/p&gt;

&lt;p&gt;Pretty nasty, right? We could try to reduce the proof of possesion here by
enforcing Alice’s environment to also store some blobs she don’t have keys to.
But if we’d like to ensure that possession of encrypted data does not mean
possession of unencrypted one, the percentage of data Alice stores and is able
to decrypt would have to be really low.&lt;/p&gt;

&lt;p&gt;When such storage overkill could be practical? One case that comes to my mind
is when Alice would provide storage services to Bob and many other people and
keep backups of their encrypted blobs. Sounds like a good idea to explore in the
future, I still see many potential risks here though.&lt;/p&gt;

&lt;h1 id=&quot;derived-nondeterministic-keys&quot;&gt;Derived Nondeterministic Keys&lt;/h1&gt;

&lt;p&gt;There’s a simple method though to keep some benefits of deduplication and still
provide security against blob corelation between users.&lt;/p&gt;

&lt;p&gt;What if we would be able to securely generate keys from blob’s contents but
those keys would be deterministic for one user only? To do that we need one more
thing - something that would represent user’s identity. One of obvious answers
here is to use assymetric keys.&lt;/p&gt;

&lt;p&gt;Private key in assymetric crypto can be used to sign the message. Signing
different messages will produce different result and common low-level crypto
primitives yield same sign for the same data (they are
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pure_function&quot;&gt;pure functions&lt;/a&gt;).
If the sign has enough entropy
for being good key source (and it has to, otherwise we would be able to fake
signs), we can apply key derivation function on it to build the encryption key.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/ditaa/ditaa-41216527d7f7b9fa2a20b1ad35cc12b25249dda1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This structure has few really nice properties:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Every blob has unique key&lt;/li&gt;
  &lt;li&gt;IV can be hardcoded for nonce-based encryption modes since we’re changing
key for every blob&lt;/li&gt;
  &lt;li&gt;Two user private keys will generate diferent encryption key for same
plaintext data&lt;/li&gt;
  &lt;li&gt;Same user will generate same key and same encrypted data for same plaintext
data&lt;/li&gt;
  &lt;li&gt;Encryption key is indistinguishable from random key for someone who doesn’t
have access to private user key&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ok, so we see that keys will be unique but only when using same private key.
But I’d like to take a look at the last property - indistinguishibility from
random. This could be really useful in some cases. Let’s say someone publishes
some important information using this key generation method. Published blob
would first look like the one using random key. If someone would later require
a proof of authenticity of this data, the published can publish the sign of
this blob. Such sign would a) produce encryption key for the blob when put
through KDF and b) the sign would prove that the blob was generated with person
in possession of the private key.&lt;/p&gt;

&lt;p&gt;Now there’s a property of deniability here. If the sign is not published, there’s
no way to connect it with the publisher. Whether it would prove itself useful,
I don’t know yet but it’s good to have such ideas for later.&lt;/p&gt;

&lt;h1 id=&quot;other-options&quot;&gt;Other options&lt;/h1&gt;

&lt;p&gt;We could also find few other methods to generate keys here. We could for example
generate one global encryption key for the user and for every blob use IV being
a hash of blob’s unencrypted contents. We could also build keys by hashing
blob’s content with some prefix and suffix. But in general we can divide
our methods into three groups:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Method&lt;/th&gt;
      &lt;th&gt;Dedupliation&lt;/th&gt;
      &lt;th&gt;Good usage&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Random&lt;/td&gt;
      &lt;td&gt;None&lt;/td&gt;
      &lt;td&gt;Highly confidential data&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Derived Deterministic&lt;/td&gt;
      &lt;td&gt;Global&lt;/td&gt;
      &lt;td&gt;Published data&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Derived Nondeterministic&lt;/td&gt;
      &lt;td&gt;Local&lt;/td&gt;
      &lt;td&gt;Backup with deduplication&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;I don’t see that any of different key generation schemes should be preffered.
Instead I think key generation should be adjusted to blob usage. If it would
become public at some point, key derived from contents is the best way to go.
Mixing it with private key signing does allow extra identity proof. Using purely
random keys could also be useful if you’d like to hide the fact of possession of
shared data. A robust system should enable them all.&lt;/p&gt;

&lt;h1 id=&quot;transparent-transport&quot;&gt;Transparent transport&lt;/h1&gt;

&lt;p&gt;You could already have noted that no matter what key encryption do we use, it
is not relevant from the point of view of CAS itself. As long as there are no
plaintext keys sent to storage system, it doesn’t have access to plaintext data.&lt;/p&gt;

&lt;p&gt;Such storage is able to do some basic verification of the blob though.
If user has to upload blob along with it’s name, such blob can be rejected
if the name does not match the contents. It’s pretty nice property since even
without the knowledge of plaintext data, the storage system can do a basic
integrity verification preventing transfer of malformed data.&lt;/p&gt;

&lt;p&gt;That’s it for this day. Hope to write something more soon.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Static base</title>
   <link href="http://cinode.github.io/2016/06/11/static-base"/>
   <updated>2016-06-11T00:00:00+02:00</updated>
   <id>http://cinode.github.io/2016/06/11/static-base</id>
   <content type="html">
&lt;h1 id=&quot;lets-talk-about-blobs&quot;&gt;Let’s talk about blobs&lt;/h1&gt;

&lt;p&gt;Computers understand bits, bits form bytes. Bytes can be ordered into sequence:
we end up having blocks of data, blobs. We store them in various places. Running
program will need some data inside memory, other part of it will be saved on disk.
Some data will be downloaded from servers, CPU will keep some blobs inside
it’s cache. We can put dozens of examples here, but what this shows is that
being so fundamental in computer science, proper data blob management is the key
to good application environment.&lt;/p&gt;

&lt;p&gt;We can’t access data without naming blobs in some way. That’s why come up with
vrious kinds of addressing. Address could be an URI, file name or just an
address in memory.&lt;/p&gt;

&lt;p&gt;There’s one special kind of addressing where we generate the name of blob from
the data itself, commonly used in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Content-addressable_storage&quot;&gt;Content-Addressable Storages&lt;/a&gt;
(CAS).
How do we generate the name of object? Well, we usually take some
cryptographically secure hash function, hash the contents of a blob and the
result of the hash function is blob’s name.&lt;/p&gt;

&lt;p&gt;What would be properties of such hash-based naming scheme?
Let’s try to figure our few:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Two blobs with equal contents will have the same name, that’s how hash
functions work.&lt;/li&gt;
  &lt;li&gt;If two blobs have same name, they almost certainly
have the same contents. Probability of a different situation is equal to
hash function collision, so
&lt;a href=&quot;https://en.wikipedia.org/wiki/Collision_resistance&quot;&gt;must be negligible&lt;/a&gt;
for any good hash function. This property could be handy in case of
deduplication since we would only have to compare short names of blobs
instead of full contents.&lt;/li&gt;
  &lt;li&gt;Changing even one bit, or changing the size of blob by even one byte would
generate totally different name. That means there’s no way to manipulate
blob data in such way that the resulting keys would expose some properties
we would want (not 100% sure about that, sounds logical but
is there any proof?). This also means that the distribution of keys should be
uniform in the whole key space. It may be crucial if we’d like to spread
data across network nodes.&lt;/li&gt;
  &lt;li&gt;A blob that’s stored in CAS can not be modified since any modification would
end up with totally different name. The only way to change is to erase the
old blob and put new one with new name instead.&lt;/li&gt;
  &lt;li&gt;Since names are so unique it’s safe to merge contents of two CAS systems
without conflicts and without data loss (with some basic assumptions of
course such as that there’s enough storage space and that the storage is
perfectly durable).
That’s pretty easy to understand - all blobs that are in only one source
will not collide due to different names and all blobs that are in both
sources, will have same names and thus same contents (with really high
probability).&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;git-has-cas&quot;&gt;Git has CAS&lt;/h1&gt;

&lt;p&gt;To understand a bit more what capabilities does Content-Addressable Storage (CAS)
give let’s bring a good example where it’s used. This example would be:
&lt;a href=&quot;https://git-scm.com/&quot;&gt;Git&lt;/a&gt;, and I can bet most of you have already used it or
at least heard about it.&lt;/p&gt;

&lt;p&gt;Every git commit has it’s own hash number, for example:
&lt;a href=&quot;https://github.com/torvalds/linux/commit/2dcd0af568b0cf583645c8a317dd12e344b1c72a&quot;&gt;2dcd0af&lt;/a&gt;,
you can see it all around code hosting
websites (sometimes just shortened to few first characters of full hash). This
hash is sha1 of some data blob and uniquely identifies particular code version.
In addition to commits, almost everything in git has a hash name - contents of
a file, directory listing, diff between two data blobs, probably a lot more if
you start digging through git internals.&lt;/p&gt;

&lt;p&gt;Those hashes are calculated recursively - for example data blob describing
directory will contain hashes of other directories and files inside.
This could look simillar to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Merkle_tree&quot;&gt;Merkle tree&lt;/a&gt;. One of property of such
structure is that change of one file would only regenerate it’s own hash and
hashes of directoories on the path to the root directory, nothing else. Since
this is a tree-like structure, the amount of changes applied has logarithmic
tendency, in other words: should be super fast for large, balanced directory
trees.&lt;/p&gt;

&lt;p&gt;Every git blob is unmodifiable. Once generated, you can’t change what’s behind
the hash assigned to it. You can at most delete it.
If you could change the contents, that would mean you can find sha1 collisions
(so you’d prove this hash function is not cryptographically secure). Even the
tiniest change in contents, commit message, commit dates, would result in
totally different hash. That’s one of propertie of CAS systems, and indeed Git
internally is one.&lt;/p&gt;

&lt;p&gt;But to let us, humans work with commits efficiently, Git adds extra references
(branches, tags, etc) on top of raw commit hashes. References are simillar to
symbolic links in unix filesystems - they are not the content itself. Instead
they are only linking to other locations, hashes in case of git. Link of given
name can be altered and point to something different. That’s exactly how branches work.&lt;/p&gt;

&lt;p&gt;Some references in git are also given special meaning - i.e. there could be a
‘stable’ branch always updated to the most recent stable version of the code.
It will be updated by someone allowed to do so. As long as we trust such person
and there are no security bugs in authorization layers, we could trust the code.
There’s a mechanism in Cinode simillar to references in git, but I’ll cover it
in some other blog post.&lt;/p&gt;

&lt;p&gt;Now there’s a funny fact about git, not many of us realize. If we take all git
repos from all around the world, rename all of their branches and tags in way
unique to each repository (for example by prefixing it with repository url),
we would be able to merge all those repos into one giant super-git-repository.&lt;/p&gt;

&lt;p&gt;Of couse such merge attempt wouldn’t be to practical due to git internals
(some operations do scan all blobs) but it shows that CAS systems could have
world-global namespaces. Actually one of perfect examples of such global system
is &lt;a href=&quot;https://en.wikipedia.org/wiki/Kademlia&quot;&gt;Kademlia&lt;/a&gt; used in trackerless
bittorrent. It shows that global CAS systems can work without any
central server or central management.&lt;/p&gt;

&lt;h1 id=&quot;what-about-security&quot;&gt;What about security?&lt;/h1&gt;

&lt;p&gt;Git doesn’t have encryption built-in. But other usages of CAS systems
could really benefit from one.&lt;/p&gt;

&lt;p&gt;Let’s consider any CAS storage as an untrusted party and see it as just a
communication medium between two users that want to securely exchange some
information. If we start putting data onto CAS system, it will gain access to
some obvious information:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Names of blobs&lt;/li&gt;
  &lt;li&gt;Contents of blobs&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There’s also some extra information derived from the one above and from the
communication channel:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The amount of data we store&lt;/li&gt;
  &lt;li&gt;Sizes of particular blobs&lt;/li&gt;
  &lt;li&gt;Number of blobs&lt;/li&gt;
  &lt;li&gt;Record of all upload operations metadata including:
    &lt;ul&gt;
      &lt;li&gt;time of upload&lt;/li&gt;
      &lt;li&gt;uploader’s address&lt;/li&gt;
      &lt;li&gt;upload speed (even as detailed as function over time)&lt;/li&gt;
      &lt;li&gt;errors (broken connections, unfinished uploads, reuploaded data etc)&lt;/li&gt;
      &lt;li&gt;most likely some client software information (name, version etc)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Record of all download operations metadata including:
    &lt;ul&gt;
      &lt;li&gt;times of downloads&lt;/li&gt;
      &lt;li&gt;downloader’s address&lt;/li&gt;
      &lt;li&gt;download speed (up to a function over time)&lt;/li&gt;
      &lt;li&gt;errors&lt;/li&gt;
      &lt;li&gt;most likely some client software information (name, version etc)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I’m pretty sure this list is barely scratching the surface of what other
information could be extracted. So let’s try to first imagine a simplified
problem: let’s hide real blob names and real data contents.&lt;/p&gt;

&lt;p&gt;Hiding contents is pretty trivial - we just need to use a proven encryption
methods, &lt;a href=&quot;https://en.wikipedia.org/wiki/Authenticated_encryption&quot;&gt;Authenticated Encryption&lt;/a&gt;
most likely. AE does provide confidentiality, integrity and authenticity.
Confidentiality is a must, otherwise someone else would be able to partially or
fully gain the plain blob data.&lt;/p&gt;

&lt;p&gt;Integrity is also a must to protect against
unauthorized modification… hmm, didn’t I said before you can’t modify data in
CAS? The name of blob, being cryptographically-secure hash function, actually
guarantees integrity. You just can’t alter data with given name, you also can’t
force your own name.&lt;/p&gt;

&lt;p&gt;Now how about authenticity?
According to &lt;a href=&quot;https://en.wikipedia.org/wiki/Message_authentication&quot;&gt;Wikipedia&lt;/a&gt;
it guarantees integrity (which we already have) and data source verification.
I’d like to skip authenticity at this point. Why? Because it really doesn’t
matter who has uploaded the data. It’s important that the name does match the
contents. In case of bare CAS-only storage, authenticity is not that important.
It will be truthly needed later, when we’ll be gathering blob names. We have to
get them from somewhere, right? And that information must be authenticated.
I’ll discuss here this problem in some future post.&lt;/p&gt;

&lt;p&gt;I didn’t yet cover one more thing. We’ll be encrypting blobs and store encrypted
data into CAS - that way we’ll get confidentiality and integrity. We’ll also hide
original blob name since we’ll be working on names of encrypted blobs instead.
But where we’ll get encryption keys and IV from? That’s a really good question
and I’ll leave it for the next blog post.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Humble beginning</title>
   <link href="http://cinode.github.io/2016/06/02/humble-beginning"/>
   <updated>2016-06-02T00:00:00+02:00</updated>
   <id>http://cinode.github.io/2016/06/02/humble-beginning</id>
   <content type="html">
&lt;h1 id=&quot;what&quot;&gt;What?&lt;/h1&gt;

&lt;p&gt;Cinode is an experimental protect, something like a sandbox for ideas.
It does/will utilize some crypto technologies to materialize new kind of
application environment. As a result of this project, I’d like to come
up with a pretty good idea on how we could create new set of apps built on
top of solid crypto base: secure by default but still relatively easy to create.&lt;/p&gt;

&lt;p&gt;This solid crypto base is the major goal here.&lt;/p&gt;

&lt;p&gt;Set of apps being a target for this base would be everything that requires
content storage: mailbox-like systems, backup storage, photo gallery, forum,
maybe even something facebook-like. What I won’t be targetting (at least at the
beginning) is everything that requires low latency communication - chats,
conferencing systems, payments etc.&lt;/p&gt;

&lt;p&gt;I don’t consider myself a good cryptographer but I know enough to not try to
invent to much of new stuff here. Instead, I’ll try to use as much of existing
technology as possible, so TLS and PGP are definitely a must here. Even if I’ll
have to get down to some lower-level stuff, it can’t be lower than some proven
crypto primitives such as AES+CBC (yeah, and I know about authenticated
encryption).&lt;/p&gt;

&lt;h1 id=&quot;why&quot;&gt;Why?&lt;/h1&gt;

&lt;p&gt;First and foremost there are some ideas I have to release from my head. They’re
there for much to long. But I also hope to add something to the crypto world
we have today.&lt;/p&gt;

&lt;p&gt;Two years ago, when Edward Snowden revealed the truth about surveillance
methods, it convinced me that there’s not enough of good crypto ever.
I still believe we’re lacking some major technologies and protection layers.&lt;/p&gt;

&lt;p&gt;What bothers me the most today is that lots of our activities jump into various
cloud systems. We lose control of the execution environments where our apps
are running. Few years ago I would have an external HDD to keep all my photos,
today I’d use some cloud service for that.&lt;/p&gt;

&lt;p&gt;And still, contrary to common attitude to “evil hackers” that present potential
threat to our security and safety, we rarely put companies into bad guy’s shoes.
What I really see is that we are biased, we are bribed.
There’s no healthy balance of trust anymore.&lt;/p&gt;

&lt;h1 id=&quot;how&quot;&gt;How?&lt;/h1&gt;

&lt;p&gt;In this blog series I’ll start describing what I came up with. This will be an
ongoing research - I’ll start describing aspects I consider to be good now.
I’ll also try to clarify new things I didn’t yet had chance to dig through.
Sometimes it will be stuff that’s not designed yet at all, sometimes those would
be things I’d like to fix or do better.&lt;/p&gt;

&lt;p&gt;Also please do not consider this experimental project as something secure for
now. Without a proper formal proof I wouldn’t consider this to be anything more
than childish play with “secret” notes. This place is here for discussion,
exchange of ideas and research.&lt;/p&gt;

&lt;p&gt;I also hope that nobady will use this stuff to exchange illegal content. So if
you came here with such intention, just leave. I don’t want this project to
be another bittorent, really great protocol which many consider a synonyme for
illegal today. We’ve spoiled to many great protocols already.&lt;/p&gt;

&lt;p&gt;I hope to put something new here once every week or two, all depends on the
amount of free time I’ll have.&lt;/p&gt;

&lt;p&gt;See you soon&lt;br /&gt;
BYO&lt;/p&gt;
</content>
 </entry>
 
 
</feed>
