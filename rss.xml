<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
        <title>Cinode dev blog</title>
        <description>Cinode dev blog - BYO</description>
        <link>http://cinode.github.io</link>
        <atom:link href="http://cinode.github.io/rss.xml" rel="self" type="application/rss+xml" />
        <lastBuildDate>Fri, 24 Jun 2016 12:19:06 +0200</lastBuildDate>
        <pubDate>Fri, 24 Jun 2016 12:19:06 +0200</pubDate>
        <ttl>60</ttl>


        <item>
                <title>We need trees, we need graphs</title>
                <description>
&lt;h1 id=&quot;extending-flat-blob-space&quot;&gt;Extending flat blob space&lt;/h1&gt;

&lt;p&gt;Standard CAS system gives us a flat namespace. There’s no structure of
data nor relationship between blobs. Although this could be enough for
some range of applications, better tools to organize data help simplifying apps
and sometimes is even necessary to express data access authorization.
That’s why we have to go beyond a flat structure and build more complex data
connections.&lt;/p&gt;

&lt;p&gt;A natural improvement is to build a tree - similarly to what happens with files
in filesystems. This can be easily achieved in a flat structure by
adding directory blobs. The purpose of such blobs is to list
other ones and give them useful names. Such directories are also usful to
express various access rights.&lt;/p&gt;

&lt;p&gt;Directories let us easily form trees, we just need a recursive structure where
one directory can contain subdirectories.&lt;/p&gt;

&lt;p&gt;In case of encrypted blobs, every blob may have different encryption key.
Because of that we have to embed information on how to gather encryption
keys next to the name assigned to blob. For now let’s call this information
a key info and leave the discussion on what could be stored there for later part
of this post.&lt;/p&gt;

&lt;p&gt;Naturally we see such directory structure forms a tree which is not the whole
truth. Just as in modern local filesystems, we can implement links which
extend beyond tree structure and form a graph. Same can be done in case of
our blob space. Two directories can point to the same blob, just name it
differently.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/ditaa/ditaa-6edf75e544803d2e7830178ed1c91776754cdd78.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In the example above, Blob6 can be reached through names /Name6 and
/Name3/Name5.&lt;/p&gt;

&lt;p&gt;A nice property of this graph is that it’s acyclic, at least for now before
we start extending it. This comes from the fact that we’re using CAS. Directory
has to embed blob names in it’s contents. That means we’re embedding
cryptographic hashes. If there was a cycle, we would form a structure like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/ditaa/ditaa-4db5c0c96ecac960499dadaa43b2a38b366af5b8.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This means that Dir1 wuold contain hash of Dir2, Dir2 would contain hash of Dir3,
Dir3 would contain hash of Dir1. Now, how to calculate those hashes? What would
be the data of directories? At some point we would have to guess hash of one
directory to build hashes of others. But this is agains properties of
cryptographic hash. Even if we randomly guessed hash of Dir1, recalculating it
through Dir3 and Dir2 would yield different result.
Although such cycle is not impossible, finding it would be equal to breaking
cryptographic hash function.&lt;/p&gt;

&lt;p&gt;Although being acyclic is a nice property, applications should not rely on it.
Even if there are no cycles, it’s easy to generate really long chain of
subdirectories so every application that traverses such blob trees would have
to implement some recursiveness limits to prevent long running loops.&lt;/p&gt;

&lt;h1 id=&quot;metadata&quot;&gt;Metadata&lt;/h1&gt;

&lt;p&gt;In addition to filename, given blob may have many more properties. One such
property is it’s mime type, another would be creation date. There could be
author, expiry date etc. That’s why it’s best to keep a dynamic map of such
metadata properties per each object. In fact, the name and key info could also
be considered a metadata.&lt;/p&gt;

&lt;h1 id=&quot;hidden-keys&quot;&gt;Hidden keys&lt;/h1&gt;

&lt;p&gt;As mentioned before, key info must be embedded within directory itself.
The most straightforward way to store it is to put the raw key value straight
into the info. Such key is still secured by encryption of directory blob.
Only those who have access to directory’s listing will get keys. This approach
could be fine in many cases. The root directory is then a major security gate
for the whole structure. If you know key and blob name
of such root, you then have access to everything below.&lt;/p&gt;

&lt;p&gt;There’s one risk here though - if a contents of directory blob is accidentially
published or shared with a recipient who wasn’t supposed to get the access,
there’s no way to easily revert such operation. Keys has been given, and along with
directory keys, access to every blob that could be reached from that directory
and it’s subdirectories.&lt;/p&gt;

&lt;h1 id=&quot;keys-with-a-lock&quot;&gt;Keys with a lock&lt;/h1&gt;

&lt;p&gt;Instead of full key in key info we could easily store other peace of information
that does not reveal the key itself but still must be used to build one.
Simplest solution that comes to my mind is to store key’s id instead of key’s
value. User would then have to get some keys database and figure out if inside
this database, there’s the key he needs. If he wouldn’t have the key inside
his DB, then he woudln’t have access to blob.&lt;/p&gt;

&lt;p&gt;Another solution is to store encrypted key. Now to not make words messy: in order
to get the key for that particular blob, we have to take it’s encrypted form,
get some other key (which could be directory’s key for example) and then decrypt
blob’s key. We can go into a little inception - key to decrypt blob’s key could
actually be encrypted with another key too. That key can be protected by another
key and so on:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/ditaa/ditaa-fcce9fd661071500e5151d9784117e8e9fb0fc6d.png&quot; /&gt;
This structure can be found in &lt;a href=&quot;https://www.net.t-labs.tu-berlin.de/~stefan/srds06.pdf&quot;&gt;Cryptree structure&lt;/a&gt;
and is called cryptographic link. What this basically means? If you know Key 1
then you know Key 2, if you know Key 2, then you know Key 3 and so on. Knowing
only Key 3 won’t reveal Key 1 and Key 2 but will reveal Key 4 and Key 5.&lt;/p&gt;

&lt;p&gt;Of course those keys don’t have to be used only to decrypt another keys. They
can also be used to encrypt and decrypt some other peace of information, blob
being one of them.&lt;/p&gt;

&lt;p&gt;We can also have multiple paths to one key:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/ditaa/ditaa-b681fb62e7c895e9167f16c31a15560ba4af28b3.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This is the structure I’d like to explore a bit.&lt;/p&gt;

&lt;h1 id=&quot;friend-of-friends&quot;&gt;Friend of friends&lt;/h1&gt;

&lt;p&gt;You may recall that many social platforms expose you an information up to some
level of connection. Some information is viewable by our “friends”, some is
even seen by “friends of our friends”. Let’s try to express this idea in
the world of cryptography.&lt;/p&gt;

&lt;p&gt;Our goal is to have different access rights to data
depending on the distane of the source. The distance can easily be modelled
using directory blobs and key info can be used to grant us rights:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/ditaa/ditaa-1bd5f989909421ff98a1eadbe459321ff45b948c.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In this example, each user generates 3 master keys assigned to his directory:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Key lvl1 - this is the key that gives access to all private data that sould be
accessible only by the owner. Since this key links to lvl2 and lvl3, user having
it will have access to information on all other levels.&lt;/li&gt;
  &lt;li&gt;Key lvl2 - this is the key that’s exposed to direct frinds of the user and
protects blobs that contain information visible to friends. It also links
to lvl3 key.&lt;/li&gt;
  &lt;li&gt;Key lvl3 - this is the key that protects information visible by friends of
friends.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In order for this to work, we must keep lvl1 key for ourselves, lvl2 key
must be shared with our friends and lvl3 key must be accessible to friends
of our friends. Data protection is guaranteed here. We still have to think
how to automatically expose keys to users.&lt;/p&gt;

&lt;p&gt;Giving key to friend sounds pretty trivial, we know who our friends are and we
manage those relations, it would require asymetric links from cryptree structure
but the basic rule is that we are in full control of our connections.&lt;/p&gt;

&lt;p&gt;Now, giving keys to friends of our friends may be a bit tricky though. We don’t
have access nor we manage friend relationship of our friends so granting lvl3
key must be handled automatically. In order to see a solution to this problem,
let’s picture multiple users and their keys (that’s of course not the whole
picture, I’ve removed unnecessry parts):&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/ditaa/ditaa-1451b662bfbc52f472e05705e0b835fb18e552ef.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In the example above, User1 represents the user who’s sharing his data.
User2 is a direct friend of User1. User3 is a direct friend of User 2 but is
not a direct friend of User1. Our goal is to give access to User1 lvl3 key to User3.&lt;/p&gt;

&lt;p&gt;Since User3 is a friend of User2, we know User3 knows User2 lvl2 key. We can
exploit that property and add extra blob in User2 directory that will contain
all lvl3 keys of his friends. That way, everyone who has access to USer2 lvl2
key will gain access to lvl3 keys of all his friends.&lt;/p&gt;

&lt;p&gt;This of course requires User2 to manage this extra blob with keys. But I believe
this is no more complicated than establishing friend relationship itself.
Of course the example here is simplified and will probably require more assymetric
links to make work but shows the general idea.&lt;/p&gt;

&lt;p&gt;This is just an example of how powerful directory structures could be. It does
require clever key management and some extra cryptographic primitives (such as
symmetric and assymetric ryptographic links) but it proves usefulnes of such
structure. We could probably come up with a lot more. But let’s bring some
problems that can easily arise with directory blobs.&lt;/p&gt;

&lt;h1 id=&quot;fat-dir&quot;&gt;Fat dir&lt;/h1&gt;

&lt;p&gt;As long as directory is relatively small, operations on it should be simple.
Whenever something inside such directory changes, we just update it’s contents,
reencrypt it and propagate the change up in the directory chain (I’ll discuss
where such propagtion ends in future posts).&lt;/p&gt;

&lt;p&gt;But let’s imagine a directory containing millions of entries. I can bet that
real-world applications would very quickly generate them. Now we won’t be able to
efficiently handle such amount of data. Reencryption and reupload of data could
eaisly saturate user’s resources.&lt;/p&gt;

&lt;p&gt;What we can do is to split one blob into multiple ones. This can easily be done
by creating something similar to hash map. Hashing name would then be good
enough to evenly split one huge directory into multiple smaller partial directories
plus one blob for the hash map itself.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/ditaa/ditaa-7b55f66d85f9332c881e8eb285c6c9aa020fa43e.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This solution wuld be problematic if we’d like to list an
ordered subset of entries - in such case search would have to be performed in
all partial blobs.&lt;/p&gt;

&lt;p&gt;In case where order would be needed though we could use different trick. Let’s
take all entries sorted and then split this set into similarly sized subsets.
The blob for the directory would then contain information about starting and
ending entry name and link to sub-directory blob&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/ditaa/ditaa-bb1eb47502aa6452be754649a14472317b2e2d10.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;There could be some significant problems to solve in such structure during
upgrade - we’d have to move entries between partial blobs, dynamically split and
merge to keep the balance at an acceptable level. However if we could afford
to build such directory once in a while and use it for read-only operations,
performance gain could be significant.&lt;/p&gt;

&lt;p&gt;That’s it for this post. I’m aware that I just scratched the surface and
oversimplified real problem in many cases. What I wanted to show is how
we could build complex strubtures by using simple blobs and various key
management techniques. I hope you have a generic feeling of how powerful such
system could be. One important thing to note here is that we’re still relying
on simple CAS storage below which means that the whole solution can use storage
independent from any particular vendor, can be stored in a secure way without revealing
information to 3rd parties and can scale well.&lt;/p&gt;

&lt;h1 id=&quot;are-we-done-yet-nope&quot;&gt;Are we done yet? Nope.&lt;/h1&gt;

&lt;p&gt;We still are not yet ready to build fully functional applications with what
we have so far. Although blobs started forming nice data structures, we’re
lacking some attachment points, links to this structure. And similarly to how
branch names in git let us efficiently colaborate with other people, we need
few extra primitives that would let us do the same in Cinode.&lt;/p&gt;

&lt;p&gt;But before I’ll dig into that problem, let’s first create proof-of-concept
application with things discussed so far.&lt;/p&gt;

&lt;p&gt;See you soon.&lt;/p&gt;
</description>
                <link>http://cinode.github.io/2016/06/23/we-need-trees-we-need-graphs</link>
                <guid>http://cinode.github.io/2016/06/23/we-need-trees-we-need-graphs</guid>
                <pubDate>Thu, 23 Jun 2016 00:00:00 +0200</pubDate>
        </item>

        <item>
                <title>Password please</title>
                <description>
&lt;h1 id=&quot;good-keys-bad-keys&quot;&gt;Good Keys, bad keys&lt;/h1&gt;

&lt;p&gt;When using encryption, good
&lt;a href=&quot;https://en.wikipedia.org/wiki/Key_(cryptography)&quot;&gt;encryption keys&lt;/a&gt; are
essential. They must be generated randomly and must contain enough entropy.
Otherwise we’ll open wide range of attacks on encrypted data.
In addition to the key, we also need
&lt;a href=&quot;https://en.wikipedia.org/wiki/Initialization_vector&quot;&gt;Initialization Vector&lt;/a&gt;
(IV) which doesn’t necessarily have to be secret, but still it should be either
pseudorandom or (in case of some encryption primitives) just unique when used
together with the same key (IV is then also called a nonce).&lt;/p&gt;

&lt;p&gt;We would like to apply encryption to our data blobs. Just to briefly recall,
our blobs are static, can not chagnge. Every blob has it’s own uinque name.
This name is made of cryptographically secure hash of blob’s data. This
hash also guarantees integrity of the information.&lt;/p&gt;

&lt;h1 id=&quot;randomize-everything&quot;&gt;Randomize everything&lt;/h1&gt;

&lt;p&gt;So, what would be the most trivial way of generating keys and IV.&lt;/p&gt;

&lt;p&gt;If keys should be random, and random IVs are also a good choice, why not just
randomly generate key for every blob? For AES-256 we would have to generate
more than 2^128 blobs (due to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Birthday_problem&quot;&gt;birthday paradox&lt;/a&gt;) to reuse key
with probbility of ~0.5, so even if we use always the same IV and nonce-based
encryption primitives, we’re still pretty safe.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/ditaa/ditaa-df68088d2039fef59a2cff9f19bca0337573fba8.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;What would be properties of such solution:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Every blob has unique key&lt;/li&gt;
  &lt;li&gt;IV can be hardcoded for nonce-based encryption modes since we’re changing
key for every blob&lt;/li&gt;
  &lt;li&gt;One blob encrypted twice will generate different key and different encrypted
blob&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All those properties may be both advantages and disadvantages.
Uniqueness of the key does guarantee high security but would require management
of such keys and won’t let us initilize the cipher once and reuse for multiple
blobs.&lt;/p&gt;

&lt;p&gt;Let’s take a look at the fact that reencryption will use different key - one
benefit of this approach is that if two
people encrypt the same data, keys will be different and the encrypted blob data
will be different too. The only thing equal would be the size of blob (which
can be handled by some clever splitting and merging of data). Overall this could
look like a good solution. But it has one drawback - it does take away
deduplication which is natural in case of CAS systems. We could argue that
it’s not that needed and I agree. But in case you would be uploading your own files,
finding duplicates could would be useful. Also in case of public data or data
shared among many peole it’s better to have same keys for same blobs. This would
reduce unnecesary duplicates of data and help reducing maintenance costs - less
data to manage is always easier to manage and scale.&lt;/p&gt;

&lt;h1 id=&quot;derived-deterministic-keys&quot;&gt;Derived Deterministic keys&lt;/h1&gt;

&lt;p&gt;Ok, let’s try the opposite side - let’s try to assign a key to a blob in such
way that each key can be unambigously assigned to it’s blob.&lt;/p&gt;

&lt;p&gt;Key must be random. One way to build pseudorandom number generator is to &lt;a href=&quot;https://en.wikipedia.org/wiki/Cryptographic_hash_function#Use_in_building_other_cryptographic_primitives&quot;&gt;use
cryptographic hash&lt;/a&gt;,
because cryptographic hash function should behave similarly to random function.
So why not just use the hash of blobs contents and use this hash as a key?
IV could be handled as before. For every blob we still use different key
so similarly to just random keys we can use predefined one for all our
cases (as long as we’re using nonce-based encryption primitives of course).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/ditaa/ditaa-606f3b2a8b9e82e6a384b1e7c0f5d2f2be2e3cee.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;What properties would we get here:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Every blob has unique key&lt;/li&gt;
  &lt;li&gt;IV can be hardcoded for nonce-based encryption modes since we’re changing
key for every blob&lt;/li&gt;
  &lt;li&gt;Every blob of data will have exactly one key assigned and same representation
of encrypted data&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;First two points are equal to the previous case. The third one is the
opposite so let’s take a closer look.&lt;/p&gt;

&lt;p&gt;Now we are able to introduce global deduplication mechanism. If two people upload
same data to one CAS, those uploads would be identical. Such blobs would share
keys, IVs and encrypted representation. This could mean significant reduction
of space usage and may significantly reduce network costs. But it does reveal an
extra information to external observer. If the observer finds out that Alice and
Bob uploaded same blob, he would be able to assume that they have access to same
peace of unencrypted information. In case Alice does protect her environment well
and is able to fight off all attacks, attacker may also try to attack Bob. If
Bob is not that good protecting himself, the attacker may gain plain data that
was shared between Alice nad Bob.&lt;/p&gt;

&lt;p&gt;Pretty nasty, right? We could try to reduce the proof of possesion here by
enforcing Alice’s environment to also store some blobs she don’t have keys to.
But if we’d like to ensure that possession of encrypted data does not mean
possession of unencrypted one, the percentage of data Alice stores and is able
to decrypt would have to be really low.&lt;/p&gt;

&lt;p&gt;When such storage overkill could be practical? One case that comes to my mind
is when Alice would provide storage services to Bob and many other people and
keep backups of their encrypted blobs. Sounds like a good idea to explore in the
future, I still see many potential risks here though.&lt;/p&gt;

&lt;h1 id=&quot;derived-nondeterministic-keys&quot;&gt;Derived Nondeterministic Keys&lt;/h1&gt;

&lt;p&gt;There’s a simple method though to keep some benefits of deduplication and still
provide security against blob corelation between users.&lt;/p&gt;

&lt;p&gt;What if we would be able to securely generate keys from blob’s contents but
those keys would be deterministic for one user only? To do that we need one more
thing - something that would represent user’s identity. One of obvious answers
here is to use assymetric keys.&lt;/p&gt;

&lt;p&gt;Private key in assymetric crypto can be used to sign the message. Signing
different messages will produce different result and common low-level crypto
primitives yield same sign for the same data (they are
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pure_function&quot;&gt;pure functions&lt;/a&gt;).
If the sign has enough entropy
for being good key source (and it has to, otherwise we would be able to fake
signs), we can apply key derivation function on it to build the encryption key.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/ditaa/ditaa-41216527d7f7b9fa2a20b1ad35cc12b25249dda1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This structure has few really nice properties:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Every blob has unique key&lt;/li&gt;
  &lt;li&gt;IV can be hardcoded for nonce-based encryption modes since we’re changing
key for every blob&lt;/li&gt;
  &lt;li&gt;Two user private keys will generate diferent encryption key for same
plaintext data&lt;/li&gt;
  &lt;li&gt;Same user will generate same key and same encrypted data for same plaintext
data&lt;/li&gt;
  &lt;li&gt;Encryption key is indistinguishable from random key for someone who doesn’t
have access to private user key&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ok, so we see that keys will be unique but only when using same private key.
But I’d like to take a look at the last property - indistinguishibility from
random. This could be really useful in some cases. Let’s say someone publishes
some important information using this key generation method. Published blob
would first look like the one using random key. If someone would later require
a proof of authenticity of this data, the published can publish the sign of
this blob. Such sign would a) produce encryption key for the blob when put
through KDF and b) the sign would prove that the blob was generated with person
in possession of the private key.&lt;/p&gt;

&lt;p&gt;Now there’s a property of deniability here. If the sign is not published, there’s
no way to connect it with the publisher. Whether it would prove itself useful,
I don’t know yet but it’s good to have such ideas for later.&lt;/p&gt;

&lt;h1 id=&quot;other-options&quot;&gt;Other options&lt;/h1&gt;

&lt;p&gt;We could also find few other methods to generate keys here. We could for example
generate one global encryption key for the user and for every blob use IV being
a hash of blob’s unencrypted contents. We could also build keys by hashing
blob’s content with some prefix and suffix. But in general we can divide
our methods into three groups:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Method&lt;/th&gt;
      &lt;th&gt;Dedupliation&lt;/th&gt;
      &lt;th&gt;Good usage&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Random&lt;/td&gt;
      &lt;td&gt;None&lt;/td&gt;
      &lt;td&gt;Highly confidential data&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Derived Deterministic&lt;/td&gt;
      &lt;td&gt;Global&lt;/td&gt;
      &lt;td&gt;Published data&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Derived Nondeterministic&lt;/td&gt;
      &lt;td&gt;Local&lt;/td&gt;
      &lt;td&gt;Backup with deduplication&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;I don’t see that any of different key generation schemes should be preffered.
Instead I think key generation should be adjusted to blob usage. If it would
become public at some point, key derived from contents is the best way to go.
Mixing it with private key signing does allow extra identity proof. Using purely
random keys could also be useful if you’d like to hide the fact of possession of
shared data. A robust system should enable them all.&lt;/p&gt;

&lt;h1 id=&quot;transparent-transport&quot;&gt;Transparent transport&lt;/h1&gt;

&lt;p&gt;You could already have noted that no matter what key encryption do we use, it
is not relevant from the point of view of CAS itself. As long as there are no
plaintext keys sent to storage system, it doesn’t have access to plaintext data.&lt;/p&gt;

&lt;p&gt;Such storage is able to do some basic verification of the blob though.
If user has to upload blob along with it’s name, such blob can be rejected
if the name does not match the contents. It’s pretty nice property since even
without the knowledge of plaintext data, the storage system can do a basic
integrity verification preventing transfer of malformed data.&lt;/p&gt;

&lt;p&gt;That’s it for this day. Hope to write something more soon.&lt;/p&gt;
</description>
                <link>http://cinode.github.io/2016/06/18/password-please</link>
                <guid>http://cinode.github.io/2016/06/18/password-please</guid>
                <pubDate>Sat, 18 Jun 2016 00:00:00 +0200</pubDate>
        </item>

        <item>
                <title>Static base</title>
                <description>
&lt;h1 id=&quot;lets-talk-about-blobs&quot;&gt;Let’s talk about blobs&lt;/h1&gt;

&lt;p&gt;Computers understand bits, bits form bytes. Bytes can be ordered into sequence:
we end up having blocks of data, blobs. We store them in various places. Running
program will need some data inside memory, other part of it will be saved on disk.
Some data will be downloaded from servers, CPU will keep some blobs inside
it’s cache. We can put dozens of examples here, but what this shows is that
being so fundamental in computer science, proper data blob management is the key
to good application environment.&lt;/p&gt;

&lt;p&gt;We can’t access data without naming blobs in some way. That’s why come up with
vrious kinds of addressing. Address could be an URI, file name or just an
address in memory.&lt;/p&gt;

&lt;p&gt;There’s one special kind of addressing where we generate the name of blob from
the data itself, commonly used in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Content-addressable_storage&quot;&gt;Content-Addressable Storages&lt;/a&gt;
(CAS).
How do we generate the name of object? Well, we usually take some
cryptographically secure hash function, hash the contents of a blob and the
result of the hash function is blob’s name.&lt;/p&gt;

&lt;p&gt;What would be properties of such hash-based naming scheme?
Let’s try to figure our few:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Two blobs with equal contents will have the same name, that’s how hash
functions work.&lt;/li&gt;
  &lt;li&gt;If two blobs have same name, they almost certainly
have the same contents. Probability of a different situation is equal to
hash function collision, so
&lt;a href=&quot;https://en.wikipedia.org/wiki/Collision_resistance&quot;&gt;must be negligible&lt;/a&gt;
for any good hash function. This property could be handy in case of
deduplication since we would only have to compare short names of blobs
instead of full contents.&lt;/li&gt;
  &lt;li&gt;Changing even one bit, or changing the size of blob by even one byte would
generate totally different name. That means there’s no way to manipulate
blob data in such way that the resulting keys would expose some properties
we would want (not 100% sure about that, sounds logical but
is there any proof?). This also means that the distribution of keys should be
uniform in the whole key space. It may be crucial if we’d like to spread
data across network nodes.&lt;/li&gt;
  &lt;li&gt;A blob that’s stored in CAS can not be modified since any modification would
end up with totally different name. The only way to change is to erase the
old blob and put new one with new name instead.&lt;/li&gt;
  &lt;li&gt;Since names are so unique it’s safe to merge contents of two CAS systems
without conflicts and without data loss (with some basic assumptions of
course such as that there’s enough storage space and that the storage is
perfectly durable).
That’s pretty easy to understand - all blobs that are in only one source
will not collide due to different names and all blobs that are in both
sources, will have same names and thus same contents (with really high
probability).&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;git-has-cas&quot;&gt;Git has CAS&lt;/h1&gt;

&lt;p&gt;To understand a bit more what capabilities does Content-Addressable Storage (CAS)
give let’s bring a good example where it’s used. This example would be:
&lt;a href=&quot;https://git-scm.com/&quot;&gt;Git&lt;/a&gt;, and I can bet most of you have already used it or
at least heard about it.&lt;/p&gt;

&lt;p&gt;Every git commit has it’s own hash number, for example:
&lt;a href=&quot;https://github.com/torvalds/linux/commit/2dcd0af568b0cf583645c8a317dd12e344b1c72a&quot;&gt;2dcd0af&lt;/a&gt;,
you can see it all around code hosting
websites (sometimes just shortened to few first characters of full hash). This
hash is sha1 of some data blob and uniquely identifies particular code version.
In addition to commits, almost everything in git has a hash name - contents of
a file, directory listing, diff between two data blobs, probably a lot more if
you start digging through git internals.&lt;/p&gt;

&lt;p&gt;Those hashes are calculated recursively - for example data blob describing
directory will contain hashes of other directories and files inside.
This could look simillar to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Merkle_tree&quot;&gt;Merkle tree&lt;/a&gt;. One of property of such
structure is that change of one file would only regenerate it’s own hash and
hashes of directoories on the path to the root directory, nothing else. Since
this is a tree-like structure, the amount of changes applied has logarithmic
tendency, in other words: should be super fast for large, balanced directory
trees.&lt;/p&gt;

&lt;p&gt;Every git blob is unmodifiable. Once generated, you can’t change what’s behind
the hash assigned to it. You can at most delete it.
If you could change the contents, that would mean you can find sha1 collisions
(so you’d prove this hash function is not cryptographically secure). Even the
tiniest change in contents, commit message, commit dates, would result in
totally different hash. That’s one of propertie of CAS systems, and indeed Git
internally is one.&lt;/p&gt;

&lt;p&gt;But to let us, humans work with commits efficiently, Git adds extra references
(branches, tags, etc) on top of raw commit hashes. References are simillar to
symbolic links in unix filesystems - they are not the content itself. Instead
they are only linking to other locations, hashes in case of git. Link of given
name can be altered and point to something different. That’s exactly how branches work.&lt;/p&gt;

&lt;p&gt;Some references in git are also given special meaning - i.e. there could be a
‘stable’ branch always updated to the most recent stable version of the code.
It will be updated by someone allowed to do so. As long as we trust such person
and there are no security bugs in authorization layers, we could trust the code.
There’s a mechanism in Cinode simillar to references in git, but I’ll cover it
in some other blog post.&lt;/p&gt;

&lt;p&gt;Now there’s a funny fact about git, not many of us realize. If we take all git
repos from all around the world, rename all of their branches and tags in way
unique to each repository (for example by prefixing it with repository url),
we would be able to merge all those repos into one giant super-git-repository.&lt;/p&gt;

&lt;p&gt;Of couse such merge attempt wouldn’t be to practical due to git internals
(some operations do scan all blobs) but it shows that CAS systems could have
world-global namespaces. Actually one of perfect examples of such global system
is &lt;a href=&quot;https://en.wikipedia.org/wiki/Kademlia&quot;&gt;Kademlia&lt;/a&gt; used in trackerless
bittorrent. It shows that global CAS systems can work without any
central server or central management.&lt;/p&gt;

&lt;h1 id=&quot;what-about-security&quot;&gt;What about security?&lt;/h1&gt;

&lt;p&gt;Git doesn’t have encryption built-in. But other usages of CAS systems
could really benefit from one.&lt;/p&gt;

&lt;p&gt;Let’s consider any CAS storage as an untrusted party and see it as just a
communication medium between two users that want to securely exchange some
information. If we start putting data onto CAS system, it will gain access to
some obvious information:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Names of blobs&lt;/li&gt;
  &lt;li&gt;Contents of blobs&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There’s also some extra information derived from the one above and from the
communication channel:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The amount of data we store&lt;/li&gt;
  &lt;li&gt;Sizes of particular blobs&lt;/li&gt;
  &lt;li&gt;Number of blobs&lt;/li&gt;
  &lt;li&gt;Record of all upload operations metadata including:
    &lt;ul&gt;
      &lt;li&gt;time of upload&lt;/li&gt;
      &lt;li&gt;uploader’s address&lt;/li&gt;
      &lt;li&gt;upload speed (even as detailed as function over time)&lt;/li&gt;
      &lt;li&gt;errors (broken connections, unfinished uploads, reuploaded data etc)&lt;/li&gt;
      &lt;li&gt;most likely some client software information (name, version etc)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Record of all download operations metadata including:
    &lt;ul&gt;
      &lt;li&gt;times of downloads&lt;/li&gt;
      &lt;li&gt;downloader’s address&lt;/li&gt;
      &lt;li&gt;download speed (up to a function over time)&lt;/li&gt;
      &lt;li&gt;errors&lt;/li&gt;
      &lt;li&gt;most likely some client software information (name, version etc)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I’m pretty sure this list is barely scratching the surface of what other
information could be extracted. So let’s try to first imagine a simplified
problem: let’s hide real blob names and real data contents.&lt;/p&gt;

&lt;p&gt;Hiding contents is pretty trivial - we just need to use a proven encryption
methods, &lt;a href=&quot;https://en.wikipedia.org/wiki/Authenticated_encryption&quot;&gt;Authenticated Encryption&lt;/a&gt;
most likely. AE does provide confidentiality, integrity and authenticity.
Confidentiality is a must, otherwise someone else would be able to partially or
fully gain the plain blob data.&lt;/p&gt;

&lt;p&gt;Integrity is also a must to protect against
unauthorized modification… hmm, didn’t I said before you can’t modify data in
CAS? The name of blob, being cryptographically-secure hash function, actually
guarantees integrity. You just can’t alter data with given name, you also can’t
force your own name.&lt;/p&gt;

&lt;p&gt;Now how about authenticity?
According to &lt;a href=&quot;https://en.wikipedia.org/wiki/Message_authentication&quot;&gt;Wikipedia&lt;/a&gt;
it guarantees integrity (which we already have) and data source verification.
I’d like to skip authenticity at this point. Why? Because it really doesn’t
matter who has uploaded the data. It’s important that the name does match the
contents. In case of bare CAS-only storage, authenticity is not that important.
It will be truthly needed later, when we’ll be gathering blob names. We have to
get them from somewhere, right? And that information must be authenticated.
I’ll discuss here this problem in some future post.&lt;/p&gt;

&lt;p&gt;I didn’t yet cover one more thing. We’ll be encrypting blobs and store encrypted
data into CAS - that way we’ll get confidentiality and integrity. We’ll also hide
original blob name since we’ll be working on names of encrypted blobs instead.
But where we’ll get encryption keys and IV from? That’s a really good question
and I’ll leave it for the next blog post.&lt;/p&gt;
</description>
                <link>http://cinode.github.io/2016/06/11/static-base</link>
                <guid>http://cinode.github.io/2016/06/11/static-base</guid>
                <pubDate>Sat, 11 Jun 2016 00:00:00 +0200</pubDate>
        </item>

        <item>
                <title>Humble beginning</title>
                <description>
&lt;h1 id=&quot;what&quot;&gt;What?&lt;/h1&gt;

&lt;p&gt;Cinode is an experimental protect, something like a sandbox for ideas.
It does/will utilize some crypto technologies to materialize new kind of
application environment. As a result of this project, I’d like to come
up with a pretty good idea on how we could create new set of apps built on
top of solid crypto base: secure by default but still relatively easy to create.&lt;/p&gt;

&lt;p&gt;This solid crypto base is the major goal here.&lt;/p&gt;

&lt;p&gt;Set of apps being a target for this base would be everything that requires
content storage: mailbox-like systems, backup storage, photo gallery, forum,
maybe even something facebook-like. What I won’t be targetting (at least at the
beginning) is everything that requires low latency communication - chats,
conferencing systems, payments etc.&lt;/p&gt;

&lt;p&gt;I don’t consider myself a good cryptographer but I know enough to not try to
invent to much of new stuff here. Instead, I’ll try to use as much of existing
technology as possible, so TLS and PGP are definitely a must here. Even if I’ll
have to get down to some lower-level stuff, it can’t be lower than some proven
crypto primitives such as AES+CBC (yeah, and I know about authenticated
encryption).&lt;/p&gt;

&lt;h1 id=&quot;why&quot;&gt;Why?&lt;/h1&gt;

&lt;p&gt;First and foremost there are some ideas I have to release from my head. They’re
there for much to long. But I also hope to add something to the crypto world
we have today.&lt;/p&gt;

&lt;p&gt;Two years ago, when Edward Snowden revealed the truth about surveillance
methods, it convinced me that there’s not enough of good crypto ever.
I still believe we’re lacking some major technologies and protection layers.&lt;/p&gt;

&lt;p&gt;What bothers me the most today is that lots of our activities jump into various
cloud systems. We lose control of the execution environments where our apps
are running. Few years ago I would have an external HDD to keep all my photos,
today I’d use some cloud service for that.&lt;/p&gt;

&lt;p&gt;And still, contrary to common attitude to “evil hackers” that present potential
threat to our security and safety, we rarely put companies into bad guy’s shoes.
What I really see is that we are biased, we are bribed.
There’s no healthy balance of trust anymore.&lt;/p&gt;

&lt;h1 id=&quot;how&quot;&gt;How?&lt;/h1&gt;

&lt;p&gt;In this blog series I’ll start describing what I came up with. This will be an
ongoing research - I’ll start describing aspects I consider to be good now.
I’ll also try to clarify new things I didn’t yet had chance to dig through.
Sometimes it will be stuff that’s not designed yet at all, sometimes those would
be things I’d like to fix or do better.&lt;/p&gt;

&lt;p&gt;Also please do not consider this experimental project as something secure for
now. Without a proper formal proof I wouldn’t consider this to be anything more
than childish play with “secret” notes. This place is here for discussion,
exchange of ideas and research.&lt;/p&gt;

&lt;p&gt;I also hope that nobady will use this stuff to exchange illegal content. So if
you came here with such intention, just leave. I don’t want this project to
be another bittorent, really great protocol which many consider a synonyme for
illegal today. We’ve spoiled to many great protocols already.&lt;/p&gt;

&lt;p&gt;I hope to put something new here once every week or two, all depends on the
amount of free time I’ll have.&lt;/p&gt;

&lt;p&gt;See you soon&lt;br /&gt;
BYO&lt;/p&gt;
</description>
                <link>http://cinode.github.io/2016/06/02/humble-beginning</link>
                <guid>http://cinode.github.io/2016/06/02/humble-beginning</guid>
                <pubDate>Thu, 02 Jun 2016 00:00:00 +0200</pubDate>
        </item>


</channel>
</rss>
