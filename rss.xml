<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
        <title>Cinode dev blog</title>
        <description>Cinode dev blog - BYO</description>
        <link>http://cinode.github.io</link>
        <atom:link href="http://cinode.github.io/rss.xml" rel="self" type="application/rss+xml" />
        <lastBuildDate>Tue, 20 Sep 2016 22:16:13 +0200</lastBuildDate>
        <pubDate>Tue, 20 Sep 2016 22:16:13 +0200</pubDate>
        <ttl>60</ttl>


        <item>
                <title>Encrypt &#39;em all</title>
                <description>
&lt;h1 id=&quot;another-step-in-the-implementation-journey&quot;&gt;Another step in the implementation journey&lt;/h1&gt;

&lt;p&gt;This time we’ll take a look at &lt;a href=&quot;https://github.com/cinode/go/tree/v2016-09-12/blenc&quot;&gt;the implementation of blob encryption layer&lt;/a&gt;. Just before we start I give you one puzzle to solve - there’s one serious security flow in   current implementation. I wonder if you’ll be able to spot it. I plan to  show and fix it in the next post.&lt;/p&gt;

&lt;h1 id=&quot;general-idea&quot;&gt;General idea&lt;/h1&gt;

&lt;p&gt;Blob encryption will be another layer of code, separate from the fist one - datastore. To keep it isolated, it will have it’s own namespace: blenc. (Yup, I was too lazy to come up with a better name ;))&lt;/p&gt;

&lt;p&gt;What would be the purpose of this layer? It will handle three major operations:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Encrypt data&lt;/li&gt;
  &lt;li&gt;Decrypt data&lt;/li&gt;
  &lt;li&gt;Generate encryption parameters (keys, ciphers, IVs)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Encryption and decryption is pretty obvious here: on the one end of the layer we’ll be talking in plain text, on the other side we’ll only see the encrypted stuff.&lt;/p&gt;

&lt;p&gt;This layer also handles selection of ciphers and their parameters. Since we’re handling both cipher selection and encryption parameters in a code close to each other, it will be easier to match them correctly and avoid subtle bugs leading to security disasters.&lt;/p&gt;

&lt;h1 id=&quot;ciphers&quot;&gt;Ciphers&lt;/h1&gt;

&lt;p&gt;I decided to use stream ciphers. It simplifies implementation since no secure padding is needed to round data to block size. Also, the size of encrypted blob and the plaintext one is the same. This is both good and bad - good since we’re not occupying more space due to encryption, bad because it reveals the size of the original data. It’s not yet a security flow but something to think about in layers on higher levels where we can handle the issue much more efficiently.&lt;/p&gt;

&lt;p&gt;Currently there are two well-known ciphers supported in the code: &lt;a href=&quot;https://github.com/cinode/go/blob/v2016-09-12/blenc/cipher_factory.go#L69&quot;&gt;AES256-CTR&lt;/a&gt; and &lt;a href=&quot;https://github.com/cinode/go/blob/v2016-09-12/blenc/cipher_factory.go#L80&quot;&gt;ChaCha20&lt;/a&gt;. &lt;a href=&quot;https://pl.wikipedia.org/wiki/Advanced_Encryption_Standard&quot;&gt;AES&lt;/a&gt; was obvious for it’s wide adoption and years of cryptoanalysis. Used with CTR mode it creates really strong stream cipher. &lt;a href=&quot;https://en.wikipedia.org/wiki/Salsa20#ChaCha_variant&quot;&gt;ChaCha20&lt;/a&gt; turns out to be good choice too. It’s strength is in it’s great performance (especially on mobiles where there’s no hardware aceleration for AES). If you wonder whether anybody you know is using it in production now, take a look at &lt;a href=&quot;https://blog.cloudflare.com/do-the-chacha-better-mobile-performance-with-cryptography/&quot;&gt;Cloudflare&lt;/a&gt; and &lt;a href=&quot;https://security.googleblog.com/2014/04/speeding-up-and-strengthening-https.html&quot;&gt;Google&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I have selected &lt;a href=&quot;https://github.com/cinode/go/blob/v2016-09-12/blenc/cipher_factory.go#L22&quot;&gt;ChaCha20&lt;/a&gt; to be the default encryption cipher. I believe it has a great potential and will become more widely adopted in the world of smaller devices (IoT is just around the corner). The &lt;a href=&quot;https://github.com/yawning/chacha20&quot;&gt;implementation&lt;/a&gt; you can find in go is also very fast, easily outperforming AES if no hardware acceleration is present.&lt;/p&gt;

&lt;h1 id=&quot;keygens&quot;&gt;KeyGens&lt;/h1&gt;

&lt;p&gt;Key generation was a bit tricky. First I implemented trivial key generator that always returns &lt;a href=&quot;https://github.com/cinode/go/blob/v2016-09-12/blenc/keygenerator_contant.go&quot;&gt;predefined key data&lt;/a&gt;. Because the same IV is used for every blob, this implementation is really unsafe and fundamentally broken - it will generate the same key+IV pairs for many blobs. Because of that, the implementation is internal to the module and I use it only for testing purposes.&lt;/p&gt;

&lt;p&gt;Another simple implementation was a &lt;a href=&quot;https://github.com/cinode/go/blob/v2016-09-12/blenc/keygenerator_random.go&quot;&gt;random key generator&lt;/a&gt;. It’s almost as simple as the constant-key one but it does provide high quality random keys. As long as we’re not relying on data deduplication, this method is the best way to generate keys.&lt;/p&gt;

&lt;p&gt;The last key generator I implemented in this iteration was a &lt;a href=&quot;https://github.com/cinode/go/blob/v2016-09-12/blenc/keygenerator_contents.go&quot;&gt;contents-based key generator&lt;/a&gt;. It’s purpose is to create key from the hash of blob’s contents. It is secure because it will generate different keys for different blobs - that requirement is guaranteed by collision resistance property of cryptographic hash function. This generator is the only one so far which requires reading whole data bufer (to calculate hash) before we start encrypting it. Data source is given as only io.Reader interface - meaning we can not seek back. This forces us to store the data in some kind of temporary buffer - and this was the hardest part to implement for this key generation scheme.&lt;/p&gt;

&lt;h1 id=&quot;tricky-buffer&quot;&gt;Tricky buffer&lt;/h1&gt;

&lt;p&gt;There are few naïve approaches to temporary buffer. First is to store everything in memory. Of course this would limit the size of blobs we could handle. Another idea is to store the data in some temporary file and then read id back. It sounds like a much better approach and has indeed been used in my implementation but if implemented incorrectly it would lead to serious security flows.&lt;/p&gt;

&lt;p&gt;First of all, the data stored in temporary files could accidentally be made readable by other users on the same system revealing plaintext data to them. Second, this data would end up being written down onto local filesystem and HDD - secure erasure of data is not a trivial problem and in case of flash-based memory may not be possible at all. That’s why in my implementation I’m storing the data in an encrypted form. The key is random and is kept inside memory only. Losing the key means losing access to the plaintext which is exactly what we need. There’s a large encryption overhead though (3x: encrypt data when storing to temporary file, decrypt data when reading from temporary file and do the final encryption) but I believe it’s worth it. The implementation of secure temporary buffer is &lt;a href=&quot;https://github.com/cinode/go/blob/v2016-09-12/blenc/secure_temp_buffer.go&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Even if we store data encrypted on a temporary location we may still fail to protect against tempering of encrypted data - a common mistake if data integrity is not checked. To overcome this issue in my implementation, I created a &lt;a href=&quot;https://github.com/cinode/go/blob/v2016-09-12/blenc/reader_hash_validator.go&quot;&gt;reader validating hash of it’s data&lt;/a&gt;. It’s purpose is to check if the data read through it has given hash value and reject the stream if it’s not. Since we already have the hash of the original, unencrypted data (it will be used to generate encryption key), we can use it to check the integrity when we read back from temporary buffer.&lt;/p&gt;

&lt;h1 id=&quot;not-all-done-yet&quot;&gt;Not all done yet&lt;/h1&gt;

&lt;p&gt;I didn’t implement everything in this layer yet. On the list of things left to do is the key generator using cyprographic signs and http interface. I leave those for some future updates - I believe enough has been implemented to move on to the next layer that would create a solid base for applications hosted in Cinode.&lt;/p&gt;

&lt;p&gt;See you at the next post.&lt;/p&gt;
</description>
                <link>http://cinode.github.io/2016/09/12/encrypt-em-all</link>
                <guid>http://cinode.github.io/2016/09/12/encrypt-em-all</guid>
                <pubDate>Mon, 12 Sep 2016 00:00:00 +0200</pubDate>
        </item>

        <item>
                <title>Refactoring mistakes</title>
                <description>
&lt;h1 id=&quot;mistake-what-mistake&quot;&gt;Mistake? What mistake?&lt;/h1&gt;

&lt;p&gt;So far we’ve implemented CAS layer. It already looks pretty nice and has high
test coverage. But I made one small mistake there. Athough CAS is currently
doing what it’s supposed to do, it will have to be extended later to gain a bit
of dynamic features. Using CAS name for such extended module would be
misleading. That’s why it has to be renamed.&lt;/p&gt;

&lt;p&gt;I’ve chosen &lt;code&gt;datastore&lt;/code&gt; for the new name. It’s really generic, informs that
module with it’s name will store data but doesn’t bring any serious limits.&lt;/p&gt;

&lt;p&gt;The only thing left to do was to change the code and try to not break something.&lt;/p&gt;

&lt;h1 id=&quot;refactools&quot;&gt;RefacTools&lt;/h1&gt;

&lt;p&gt;Refactoring in golang is relatively simple thanks to tools such as
&lt;a href=&quot;https://golang.org/cmd/gofmt/&quot;&gt;gofmt&lt;/a&gt;,
&lt;a href=&quot;https://godoc.org/golang.org/x/tools/cmd/gomvpkg&quot;&gt;gomvpkg&lt;/a&gt; or
&lt;a href=&quot;https://godoc.org/golang.org/x/tools/cmd/gorename&quot;&gt;gorename&lt;/a&gt;. Most of the time
I spend adjusting comments and searching for incorrect names.&lt;/p&gt;

&lt;p&gt;And thanks God I had enough testing coverage to quickly ensure everything
compiles and runs as expected.&lt;/p&gt;

&lt;p&gt;That would be the end of this short post. The result of today’s post is
&lt;a href=&quot;https://github.com/cinode/go/tree/v2016-08-08&quot;&gt;here&lt;/a&gt;. Please take a look if you’re curious what has changed.&lt;/p&gt;

&lt;p&gt;Bye&lt;/p&gt;
</description>
                <link>http://cinode.github.io/2016/08/08/refactoring-mistakes</link>
                <guid>http://cinode.github.io/2016/08/08/refactoring-mistakes</guid>
                <pubDate>Mon, 08 Aug 2016 00:00:00 +0200</pubDate>
        </item>

        <item>
                <title>CAS in action</title>
                <description>
&lt;h1 id=&quot;tough-decisions&quot;&gt;Tough decisions&lt;/h1&gt;

&lt;p&gt;Before I jump to description of the code itself, let’s first clarify what
technology I’ll be using to write Cinode prototype. I decided to use
&lt;a href=&quot;https://golang.org/&quot;&gt;golang&lt;/a&gt;. I find it rather nice to work with but it also
has some thorns here and there. Why would I like to use it then? It turns out to
be very practical, especially in the field of network services. Goroutines are
just great - no need to think in terms of callbacks anymore, just straight,
sequential code.&lt;/p&gt;

&lt;p&gt;Golang also has everything we’ll need to build the prototype - all crypto
primitives and nice toolset for a http-based services. I don’t expect this
prototype to be a performance rocket but the speed that golang would give us
should be enough.&lt;/p&gt;

&lt;p&gt;I must also admit that I don’t yet care to much about cross-process memory
safety. There will be a lot of keys and passphrases in the memory but we don’t
want to protect against attacker who can read that, it’s still a prototype,
right? Keeping that in mind, golang is just a perfect match here.&lt;/p&gt;

&lt;p&gt;I’ll be developing on Linux platform - that’s my primary OS but I’ll try not to
use any os-specific constructs. Of course I strongly recommend Linux for any
project dealing with network, especially if it supports our freedom. But I won’t
force you to use it. Freedom to choose what you want is something I do respect.
If for some reason this project won’t work well on other OS-es, please keep in
ming that this wasn’t intentional. I also kindly ask you to &lt;a href=&quot;https://github.com/cinode/go/issues/new&quot;&gt;let me know about
it&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To avoid such OS misbehavior and to have good quality of the codebase, I’ll do
test driven development, maybe not in it’s strict sense, but my goal is to have
everything well tested. Golang has very good support for testing and coverage
reports so we’ll save some time to setup correct tools.&lt;/p&gt;

&lt;p&gt;The source code will be stored in &lt;a href=&quot;https://github.com/cinode/go&quot;&gt;github
repository&lt;/a&gt;, tests will be done through &lt;a href=&quot;https://travis-ci.org/cinode/go&quot;&gt;Travis
CI&lt;/a&gt;. Coverage analysis will be done using
&lt;a href=&quot;https://coveralls.io/github/cinode/go&quot;&gt;Coveralls&lt;/a&gt;. I decided to use those tools
to get most of the stuff running up quickly. Even though I had some initial
issues with setting everything up, the time win is huge here. Besides, having
everything public in public tools creates higher pressure to keep high level of
quality from the beginnig.&lt;/p&gt;

&lt;h1 id=&quot;lets-have-some-baseline&quot;&gt;Let’s have some baseline&lt;/h1&gt;

&lt;p&gt;Before any serious code was put down, I’ve set few rules I wanted to follow:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Build clean layered architecture - split the system into layers (matching&lt;br /&gt;
Cinode’s design). Each layer should be a separate module with it’s own
namespace in go.&lt;/li&gt;
  &lt;li&gt;Each module must have a clear set of interfaces it provides to communicate
with other modules and application code.&lt;/li&gt;
  &lt;li&gt;Each module’s interface must have apriopriate set of test cases covering
all interface methods&lt;/li&gt;
  &lt;li&gt;For each module there should be a reference implementation of it’s
interfaces - such implementation does not have to store data permanently
between sessions. It will be used during testing as a reference behavior of
the interface.&lt;/li&gt;
  &lt;li&gt;If there are multiple implemetnations of the module interfce, all interface
tests must be executed on all interface implementations and pass cleanly.
Additional tests should be used to cover corner cases of specific interface
implementations.&lt;/li&gt;
  &lt;li&gt;I opt for high code coverage from the beginning. Although it does not prove
that the code is bug-free, it would at least ensure most of code paths were
executed while testing.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Enough of boring talk, let’s have some code!&lt;/p&gt;

&lt;h1 id=&quot;cas-interface&quot;&gt;CAS interface&lt;/h1&gt;

&lt;p&gt;I first started with &lt;a href=&quot;https://github.com/cinode/go/blob/v2016-07-29/cas/interface.go&quot;&gt;draft
interface&lt;/a&gt;. In
CAS we need some obvious functionality: uploading blob and downloading existing
one. We also need to delete existing blob and check if one does exist. I also
knew I wouldn’t use buffers to specify data of blobs, streams would fit much
better here - that way we can put and get blobs of arbitrary size without
worrying about the amount of consumed memory.&lt;/p&gt;

&lt;p&gt;I started with a trivial implementation that was storing data &lt;a href=&quot;https://github.com/cinode/go/blob/v2016-07-29/cas/memory.go&quot;&gt;inside
memory&lt;/a&gt;. It was my
base when I was writing &lt;a href=&quot;https://github.com/cinode/go/blob/v2016-07-29/cas/interface_test.go&quot;&gt;interface
tests&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Once I felt I have enough of the interface covered, I started working on
more practical implementation storing data on &lt;a href=&quot;https://github.com/cinode/go/blob/v2016-07-29/cas/filesystem.go&quot;&gt;local
filesystem&lt;/a&gt;.
During implementation I also made small change to the interface - I split
uploading blob into two separate functions. First would be used to upload blob
when it’s name is known - such uplaod would fail if name does not match the
contents. I also made an alternative method where we only give data and get the
calculated name back.&lt;/p&gt;

&lt;p&gt;When everything was up and running I wanted to add one more functionality to the
module. In order to make first usable application I wanted to let us play with
cas using plain web browser. For this purpose I made &lt;a href=&quot;https://github.com/cinode/go/blob/v2016-07-29/cas/webinterface.go&quot;&gt;web
interface&lt;/a&gt;.
It’s purpose is to take any implementation of CAS interface and some
configuration and expose CAS functionality through http. Implementation worked
like a charm. It is very simple and follows REST design:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;GET reads a blob&lt;/li&gt;
  &lt;li&gt;POST uploads new blob if we don’t know the name&lt;/li&gt;
  &lt;li&gt;PUT uploads blob if we know the name&lt;/li&gt;
  &lt;li&gt;DELETE removea blob&lt;/li&gt;
  &lt;li&gt;HEAD finds out if blob exists&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Initially POST and PUT were taking raw post data as post body. I extended it
later to also support mnultipart/form-data content types to allow uploading from
HTML form.&lt;/p&gt;

&lt;p&gt;Once the Web Interface was ready, I needed an easy way to test it. What would
perfectly make sense here is a new implementation of CAS interface that talks to
some remotely available Web backend with compatible protocol (so a web
interface). Once I did it I could use common interface testing code. Tests were
run on CAS implementation which connected to local web interface. This web
interface on then was attached to local memory-based implementation.&lt;/p&gt;

&lt;h1 id=&quot;lets-make-it-practical&quot;&gt;Let’s make it practical&lt;/h1&gt;

&lt;p&gt;Ok, we have all those blocks of code but none of them is any useful standalone
application yet. Just bunch of code inside cas library which can’t be used
without writing some go code. We can expose CAS through HTTP, so I created a
&lt;a href=&quot;https://github.com/cinode/go/blob/v2016-07-29/cas/cmd/cinode_cas_fileserver/main.go&quot;&gt;simple
application&lt;/a&gt;
that exposes data from a local directory (so filesystem-based CAS
implementation) in a form of a simple web server. Let’s give it a try:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;# Fetch and compile server binary
go install github.com/cinode/go/cas/cmd/cinode_cas_fileserver

# Start the server, configuration is passed through environmental variables
CN_CAS_LISTEN_ADDR=127.0.0.1:8080 \
CN_CAS_DATA_FOLDER=/tmp/cinode/ \
  $GOPATH/bin/cinode_cas_fileserver
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In a separate shell:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;# Upload some data blob (extra echo needed since CAS server doesn&#39;t output
# newline character)
curl -d &quot;Hello world!&quot; http://127.0.0.1:8080/; echo
# Will output: XB5P3GWTHnHTud55BijFsGmBjHZtwtc44es4HsZnqMGM

# Download the blob (extra echo needed for reasons same as above)
curl http://127.0.0.1:8080/XB5P3GWTHnHTud55BijFsGmBjHZtwtc44es4HsZnqMGM; echo
# Will output: Hello world!

# Upload some file
echo &quot;Hello world from a file&quot; &amp;gt; /tmp/upload_file.txt
curl --form &quot;fileupload=@/tmp/upload_file.txt;filename=file.txt&quot; \
  http://127.0.0.1:8080/; echo
# Will output: WHa8NVuf1RfUVrqsyqmo2Vh1xyuVTqJqJePhjSxHwZmy

# Download the blob (no need for extra echo since the uploaded file had newline)
curl http://127.0.0.1:8080/WHa8NVuf1RfUVrqsyqmo2Vh1xyuVTqJqJePhjSxHwZmy
# Will output: Hello world from a file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A small note about those strange blob names - they don’t look like hex string
nor base64-encoded values. Instead I decided to use
&lt;a href=&quot;https://en.wikipedia.org/wiki/Base58&quot;&gt;Base58&lt;/a&gt; - it’s commonly used in BitCoin
and encodes any binary data to a string that always consists of alphanumeric
characters - a perfect selection if we don’t want to deal with encoding
incompatibilities in the future. This encoding may not be very fast but our blob
names are not that long anyway.&lt;/p&gt;

&lt;p&gt;Ok, once we have a web server and can upload some data into it, maybe we should
make some more practical use of it? First let’s try to use CAS as a storage for
html pages:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;curl -d &#39;&amp;lt;!doctype html&amp;gt;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;lt;h1&amp;gt;Hello world!&amp;lt;/h1&amp;gt;&amp;lt;/html&amp;gt;&#39; \
  http://127.0.0.1:8080/; echo
# Will output: QH9EmJveKGD1ppUgDVjBqZ8XKw4crBuSNHApgjK9RbgR

# Open in web browser
x-www-browser http://127.0.0.1:8080/QH9EmJveKGD1ppUgDVjBqZ8XKw4crBuSNHApgjK9RbgR
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I also made a simple dataset with html that lets you upload files directly from the web browser:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;git clone https://github.com/cinode/testdata-cas-filesystem.git /tmp/test-data
cd /tmp/test-data
git checkout v2016-07-29
CN_CAS_LISTEN_ADDR=127.0.0.1:8080 \
CN_CAS_DATA_FOLDER=/tmp/test-data/ \
  $GOPATH/bin/cinode_cas_fileserver
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;x-www-browser http://127.0.0.1:8080/bR9AEqo79uoYLoGx2Xf1JViBbTz5aZWBy9qkHMZxeWYM
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That’s it for today. Apart from CAS there’s still an encryption layer to be implemented. I hope to cover it in next post.&lt;/p&gt;

&lt;p&gt;Bye&lt;/p&gt;
</description>
                <link>http://cinode.github.io/2016/07/26/cas-in-action</link>
                <guid>http://cinode.github.io/2016/07/26/cas-in-action</guid>
                <pubDate>Tue, 26 Jul 2016 00:00:00 +0200</pubDate>
        </item>

        <item>
                <title>Password please</title>
                <description>
&lt;h1 id=&quot;good-keys-bad-keys&quot;&gt;Good Keys, bad keys&lt;/h1&gt;

&lt;p&gt;When using encryption, good
&lt;a href=&quot;https://en.wikipedia.org/wiki/Key_(cryptography)&quot;&gt;encryption keys&lt;/a&gt; are
essential. They must be generated randomly and must contain enough entropy.
Otherwise we’ll open wide range of attacks on encrypted data.
In addition to the key, we also need
&lt;a href=&quot;https://en.wikipedia.org/wiki/Initialization_vector&quot;&gt;Initialization Vector&lt;/a&gt;
(IV) which doesn’t necessarily have to be secret, but still it should be either
pseudorandom or (in case of some encryption primitives) just unique when used
together with the same key (IV is then also called a nonce).&lt;/p&gt;

&lt;p&gt;We would like to apply encryption to our data blobs. Just to briefly recall,
our blobs are static, can not chagnge. Every blob has it’s own uinque name.
This name is made of cryptographically secure hash of blob’s data. This
hash also guarantees integrity of the information.&lt;/p&gt;

&lt;h1 id=&quot;randomize-everything&quot;&gt;Randomize everything&lt;/h1&gt;

&lt;p&gt;So, what would be the most trivial way of generating keys and IV.&lt;/p&gt;

&lt;p&gt;If keys should be random, and random IVs are also a good choice, why not just
randomly generate key for every blob? For AES-256 we would have to generate
more than 2^128 blobs (due to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Birthday_problem&quot;&gt;birthday paradox&lt;/a&gt;) to reuse key
with probbility of ~0.5, so even if we use always the same IV and nonce-based
encryption primitives, we’re still pretty safe.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/ditaa/ditaa-df68088d2039fef59a2cff9f19bca0337573fba8.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;What would be properties of such solution:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Every blob has unique key&lt;/li&gt;
  &lt;li&gt;IV can be hardcoded for nonce-based encryption modes since we’re changing
key for every blob&lt;/li&gt;
  &lt;li&gt;One blob encrypted twice will generate different key and different encrypted
blob&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All those properties may be both advantages and disadvantages.
Uniqueness of the key does guarantee high security but would require management
of such keys and won’t let us initilize the cipher once and reuse for multiple
blobs.&lt;/p&gt;

&lt;p&gt;Let’s take a look at the fact that reencryption will use different key - one
benefit of this approach is that if two
people encrypt the same data, keys will be different and the encrypted blob data
will be different too. The only thing equal would be the size of blob (which
can be handled by some clever splitting and merging of data). Overall this could
look like a good solution. But it has one drawback - it does take away
deduplication which is natural in case of CAS systems. We could argue that
it’s not that needed and I agree. But in case you would be uploading your own files,
finding duplicates could would be useful. Also in case of public data or data
shared among many peole it’s better to have same keys for same blobs. This would
reduce unnecesary duplicates of data and help reducing maintenance costs - less
data to manage is always easier to manage and scale.&lt;/p&gt;

&lt;h1 id=&quot;derived-deterministic-keys&quot;&gt;Derived Deterministic keys&lt;/h1&gt;

&lt;p&gt;Ok, let’s try the opposite side - let’s try to assign a key to a blob in such
way that each key can be unambigously assigned to it’s blob.&lt;/p&gt;

&lt;p&gt;Key must be random. One way to build pseudorandom number generator is to &lt;a href=&quot;https://en.wikipedia.org/wiki/Cryptographic_hash_function#Use_in_building_other_cryptographic_primitives&quot;&gt;use
cryptographic hash&lt;/a&gt;,
because cryptographic hash function should behave similarly to random function.
So why not just use the hash of blobs contents and use this hash as a key?
IV could be handled as before. For every blob we still use different key
so similarly to just random keys we can use predefined one for all our
cases (as long as we’re using nonce-based encryption primitives of course).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/ditaa/ditaa-606f3b2a8b9e82e6a384b1e7c0f5d2f2be2e3cee.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;What properties would we get here:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Every blob has unique key&lt;/li&gt;
  &lt;li&gt;IV can be hardcoded for nonce-based encryption modes since we’re changing
key for every blob&lt;/li&gt;
  &lt;li&gt;Every blob of data will have exactly one key assigned and same representation
of encrypted data&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;First two points are equal to the previous case. The third one is the
opposite so let’s take a closer look.&lt;/p&gt;

&lt;p&gt;Now we are able to introduce global deduplication mechanism. If two people upload
same data to one CAS, those uploads would be identical. Such blobs would share
keys, IVs and encrypted representation. This could mean significant reduction
of space usage and may significantly reduce network costs. But it does reveal an
extra information to external observer. If the observer finds out that Alice and
Bob uploaded same blob, he would be able to assume that they have access to same
peace of unencrypted information. In case Alice does protect her environment well
and is able to fight off all attacks, attacker may also try to attack Bob. If
Bob is not that good protecting himself, the attacker may gain plain data that
was shared between Alice nad Bob.&lt;/p&gt;

&lt;p&gt;Pretty nasty, right? We could try to reduce the proof of possesion here by
enforcing Alice’s environment to also store some blobs she don’t have keys to.
But if we’d like to ensure that possession of encrypted data does not mean
possession of unencrypted one, the percentage of data Alice stores and is able
to decrypt would have to be really low.&lt;/p&gt;

&lt;p&gt;When such storage overkill could be practical? One case that comes to my mind
is when Alice would provide storage services to Bob and many other people and
keep backups of their encrypted blobs. Sounds like a good idea to explore in the
future, I still see many potential risks here though.&lt;/p&gt;

&lt;h1 id=&quot;derived-nondeterministic-keys&quot;&gt;Derived Nondeterministic Keys&lt;/h1&gt;

&lt;p&gt;There’s a simple method though to keep some benefits of deduplication and still
provide security against blob corelation between users.&lt;/p&gt;

&lt;p&gt;What if we would be able to securely generate keys from blob’s contents but
those keys would be deterministic for one user only? To do that we need one more
thing - something that would represent user’s identity. One of obvious answers
here is to use assymetric keys.&lt;/p&gt;

&lt;p&gt;Private key in assymetric crypto can be used to sign the message. Signing
different messages will produce different result and common low-level crypto
primitives yield same sign for the same data (they are
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pure_function&quot;&gt;pure functions&lt;/a&gt;).
If the sign has enough entropy
for being good key source (and it has to, otherwise we would be able to fake
signs), we can apply key derivation function on it to build the encryption key.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/ditaa/ditaa-41216527d7f7b9fa2a20b1ad35cc12b25249dda1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This structure has few really nice properties:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Every blob has unique key&lt;/li&gt;
  &lt;li&gt;IV can be hardcoded for nonce-based encryption modes since we’re changing
key for every blob&lt;/li&gt;
  &lt;li&gt;Two user private keys will generate diferent encryption key for same
plaintext data&lt;/li&gt;
  &lt;li&gt;Same user will generate same key and same encrypted data for same plaintext
data&lt;/li&gt;
  &lt;li&gt;Encryption key is indistinguishable from random key for someone who doesn’t
have access to private user key&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ok, so we see that keys will be unique but only when using same private key.
But I’d like to take a look at the last property - indistinguishibility from
random. This could be really useful in some cases. Let’s say someone publishes
some important information using this key generation method. Published blob
would first look like the one using random key. If someone would later require
a proof of authenticity of this data, the published can publish the sign of
this blob. Such sign would a) produce encryption key for the blob when put
through KDF and b) the sign would prove that the blob was generated with person
in possession of the private key.&lt;/p&gt;

&lt;p&gt;Now there’s a property of deniability here. If the sign is not published, there’s
no way to connect it with the publisher. Whether it would prove itself useful,
I don’t know yet but it’s good to have such ideas for later.&lt;/p&gt;

&lt;h1 id=&quot;other-options&quot;&gt;Other options&lt;/h1&gt;

&lt;p&gt;We could also find few other methods to generate keys here. We could for example
generate one global encryption key for the user and for every blob use IV being
a hash of blob’s unencrypted contents. We could also build keys by hashing
blob’s content with some prefix and suffix. But in general we can divide
our methods into three groups:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Method&lt;/th&gt;
      &lt;th&gt;Dedupliation&lt;/th&gt;
      &lt;th&gt;Good usage&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Random&lt;/td&gt;
      &lt;td&gt;None&lt;/td&gt;
      &lt;td&gt;Highly confidential data&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Derived Deterministic&lt;/td&gt;
      &lt;td&gt;Global&lt;/td&gt;
      &lt;td&gt;Published data&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Derived Nondeterministic&lt;/td&gt;
      &lt;td&gt;Local&lt;/td&gt;
      &lt;td&gt;Backup with deduplication&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;I don’t see that any of different key generation schemes should be preffered.
Instead I think key generation should be adjusted to blob usage. If it would
become public at some point, key derived from contents is the best way to go.
Mixing it with private key signing does allow extra identity proof. Using purely
random keys could also be useful if you’d like to hide the fact of possession of
shared data. A robust system should enable them all.&lt;/p&gt;

&lt;h1 id=&quot;transparent-transport&quot;&gt;Transparent transport&lt;/h1&gt;

&lt;p&gt;You could already have noted that no matter what key encryption do we use, it
is not relevant from the point of view of CAS itself. As long as there are no
plaintext keys sent to storage system, it doesn’t have access to plaintext data.&lt;/p&gt;

&lt;p&gt;Such storage is able to do some basic verification of the blob though.
If user has to upload blob along with it’s name, such blob can be rejected
if the name does not match the contents. It’s pretty nice property since even
without the knowledge of plaintext data, the storage system can do a basic
integrity verification preventing transfer of malformed data.&lt;/p&gt;

&lt;p&gt;That’s it for this day. Hope to write something more soon.&lt;/p&gt;
</description>
                <link>http://cinode.github.io/2016/06/18/password-please</link>
                <guid>http://cinode.github.io/2016/06/18/password-please</guid>
                <pubDate>Sat, 18 Jun 2016 00:00:00 +0200</pubDate>
        </item>

        <item>
                <title>Static base</title>
                <description>
&lt;h1 id=&quot;lets-talk-about-blobs&quot;&gt;Let’s talk about blobs&lt;/h1&gt;

&lt;p&gt;Computers understand bits, bits form bytes. Bytes can be ordered into sequence:
we end up having blocks of data, blobs. We store them in various places. Running
program will need some data inside memory, other part of it will be saved on disk.
Some data will be downloaded from servers, CPU will keep some blobs inside
it’s cache. We can put dozens of examples here, but what this shows is that
being so fundamental in computer science, proper data blob management is the key
to good application environment.&lt;/p&gt;

&lt;p&gt;We can’t access data without naming blobs in some way. That’s why come up with
vrious kinds of addressing. Address could be an URI, file name or just an
address in memory.&lt;/p&gt;

&lt;p&gt;There’s one special kind of addressing where we generate the name of blob from
the data itself, commonly used in
&lt;a href=&quot;https://en.wikipedia.org/wiki/Content-addressable_storage&quot;&gt;Content-Addressable Storages&lt;/a&gt;
(CAS).
How do we generate the name of object? Well, we usually take some
cryptographically secure hash function, hash the contents of a blob and the
result of the hash function is blob’s name.&lt;/p&gt;

&lt;p&gt;What would be properties of such hash-based naming scheme?
Let’s try to figure our few:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Two blobs with equal contents will have the same name, that’s how hash
functions work.&lt;/li&gt;
  &lt;li&gt;If two blobs have same name, they almost certainly
have the same contents. Probability of a different situation is equal to
hash function collision, so
&lt;a href=&quot;https://en.wikipedia.org/wiki/Collision_resistance&quot;&gt;must be negligible&lt;/a&gt;
for any good hash function. This property could be handy in case of
deduplication since we would only have to compare short names of blobs
instead of full contents.&lt;/li&gt;
  &lt;li&gt;Changing even one bit, or changing the size of blob by even one byte would
generate totally different name. That means there’s no way to manipulate
blob data in such way that the resulting keys would expose some properties
we would want (not 100% sure about that, sounds logical but
is there any proof?). This also means that the distribution of keys should be
uniform in the whole key space. It may be crucial if we’d like to spread
data across network nodes.&lt;/li&gt;
  &lt;li&gt;A blob that’s stored in CAS can not be modified since any modification would
end up with totally different name. The only way to change is to erase the
old blob and put new one with new name instead.&lt;/li&gt;
  &lt;li&gt;Since names are so unique it’s safe to merge contents of two CAS systems
without conflicts and without data loss (with some basic assumptions of
course such as that there’s enough storage space and that the storage is
perfectly durable).
That’s pretty easy to understand - all blobs that are in only one source
will not collide due to different names and all blobs that are in both
sources, will have same names and thus same contents (with really high
probability).&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;git-has-cas&quot;&gt;Git has CAS&lt;/h1&gt;

&lt;p&gt;To understand a bit more what capabilities does Content-Addressable Storage (CAS)
give let’s bring a good example where it’s used. This example would be:
&lt;a href=&quot;https://git-scm.com/&quot;&gt;Git&lt;/a&gt;, and I can bet most of you have already used it or
at least heard about it.&lt;/p&gt;

&lt;p&gt;Every git commit has it’s own hash number, for example:
&lt;a href=&quot;https://github.com/torvalds/linux/commit/2dcd0af568b0cf583645c8a317dd12e344b1c72a&quot;&gt;2dcd0af&lt;/a&gt;,
you can see it all around code hosting
websites (sometimes just shortened to few first characters of full hash). This
hash is sha1 of some data blob and uniquely identifies particular code version.
In addition to commits, almost everything in git has a hash name - contents of
a file, directory listing, diff between two data blobs, probably a lot more if
you start digging through git internals.&lt;/p&gt;

&lt;p&gt;Those hashes are calculated recursively - for example data blob describing
directory will contain hashes of other directories and files inside.
This could look simillar to
&lt;a href=&quot;https://en.wikipedia.org/wiki/Merkle_tree&quot;&gt;Merkle tree&lt;/a&gt;. One of property of such
structure is that change of one file would only regenerate it’s own hash and
hashes of directoories on the path to the root directory, nothing else. Since
this is a tree-like structure, the amount of changes applied has logarithmic
tendency, in other words: should be super fast for large, balanced directory
trees.&lt;/p&gt;

&lt;p&gt;Every git blob is unmodifiable. Once generated, you can’t change what’s behind
the hash assigned to it. You can at most delete it.
If you could change the contents, that would mean you can find sha1 collisions
(so you’d prove this hash function is not cryptographically secure). Even the
tiniest change in contents, commit message, commit dates, would result in
totally different hash. That’s one of propertie of CAS systems, and indeed Git
internally is one.&lt;/p&gt;

&lt;p&gt;But to let us, humans work with commits efficiently, Git adds extra references
(branches, tags, etc) on top of raw commit hashes. References are simillar to
symbolic links in unix filesystems - they are not the content itself. Instead
they are only linking to other locations, hashes in case of git. Link of given
name can be altered and point to something different. That’s exactly how branches work.&lt;/p&gt;

&lt;p&gt;Some references in git are also given special meaning - i.e. there could be a
‘stable’ branch always updated to the most recent stable version of the code.
It will be updated by someone allowed to do so. As long as we trust such person
and there are no security bugs in authorization layers, we could trust the code.
There’s a mechanism in Cinode simillar to references in git, but I’ll cover it
in some other blog post.&lt;/p&gt;

&lt;p&gt;Now there’s a funny fact about git, not many of us realize. If we take all git
repos from all around the world, rename all of their branches and tags in way
unique to each repository (for example by prefixing it with repository url),
we would be able to merge all those repos into one giant super-git-repository.&lt;/p&gt;

&lt;p&gt;Of couse such merge attempt wouldn’t be to practical due to git internals
(some operations do scan all blobs) but it shows that CAS systems could have
world-global namespaces. Actually one of perfect examples of such global system
is &lt;a href=&quot;https://en.wikipedia.org/wiki/Kademlia&quot;&gt;Kademlia&lt;/a&gt; used in trackerless
bittorrent. It shows that global CAS systems can work without any
central server or central management.&lt;/p&gt;

&lt;h1 id=&quot;what-about-security&quot;&gt;What about security?&lt;/h1&gt;

&lt;p&gt;Git doesn’t have encryption built-in. But other usages of CAS systems
could really benefit from one.&lt;/p&gt;

&lt;p&gt;Let’s consider any CAS storage as an untrusted party and see it as just a
communication medium between two users that want to securely exchange some
information. If we start putting data onto CAS system, it will gain access to
some obvious information:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Names of blobs&lt;/li&gt;
  &lt;li&gt;Contents of blobs&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There’s also some extra information derived from the one above and from the
communication channel:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The amount of data we store&lt;/li&gt;
  &lt;li&gt;Sizes of particular blobs&lt;/li&gt;
  &lt;li&gt;Number of blobs&lt;/li&gt;
  &lt;li&gt;Record of all upload operations metadata including:
    &lt;ul&gt;
      &lt;li&gt;time of upload&lt;/li&gt;
      &lt;li&gt;uploader’s address&lt;/li&gt;
      &lt;li&gt;upload speed (even as detailed as function over time)&lt;/li&gt;
      &lt;li&gt;errors (broken connections, unfinished uploads, reuploaded data etc)&lt;/li&gt;
      &lt;li&gt;most likely some client software information (name, version etc)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Record of all download operations metadata including:
    &lt;ul&gt;
      &lt;li&gt;times of downloads&lt;/li&gt;
      &lt;li&gt;downloader’s address&lt;/li&gt;
      &lt;li&gt;download speed (up to a function over time)&lt;/li&gt;
      &lt;li&gt;errors&lt;/li&gt;
      &lt;li&gt;most likely some client software information (name, version etc)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I’m pretty sure this list is barely scratching the surface of what other
information could be extracted. So let’s try to first imagine a simplified
problem: let’s hide real blob names and real data contents.&lt;/p&gt;

&lt;p&gt;Hiding contents is pretty trivial - we just need to use a proven encryption
methods, &lt;a href=&quot;https://en.wikipedia.org/wiki/Authenticated_encryption&quot;&gt;Authenticated Encryption&lt;/a&gt;
most likely. AE does provide confidentiality, integrity and authenticity.
Confidentiality is a must, otherwise someone else would be able to partially or
fully gain the plain blob data.&lt;/p&gt;

&lt;p&gt;Integrity is also a must to protect against
unauthorized modification… hmm, didn’t I said before you can’t modify data in
CAS? The name of blob, being cryptographically-secure hash function, actually
guarantees integrity. You just can’t alter data with given name, you also can’t
force your own name.&lt;/p&gt;

&lt;p&gt;Now how about authenticity?
According to &lt;a href=&quot;https://en.wikipedia.org/wiki/Message_authentication&quot;&gt;Wikipedia&lt;/a&gt;
it guarantees integrity (which we already have) and data source verification.
I’d like to skip authenticity at this point. Why? Because it really doesn’t
matter who has uploaded the data. It’s important that the name does match the
contents. In case of bare CAS-only storage, authenticity is not that important.
It will be truthly needed later, when we’ll be gathering blob names. We have to
get them from somewhere, right? And that information must be authenticated.
I’ll discuss here this problem in some future post.&lt;/p&gt;

&lt;p&gt;I didn’t yet cover one more thing. We’ll be encrypting blobs and store encrypted
data into CAS - that way we’ll get confidentiality and integrity. We’ll also hide
original blob name since we’ll be working on names of encrypted blobs instead.
But where we’ll get encryption keys and IV from? That’s a really good question
and I’ll leave it for the next blog post.&lt;/p&gt;
</description>
                <link>http://cinode.github.io/2016/06/11/static-base</link>
                <guid>http://cinode.github.io/2016/06/11/static-base</guid>
                <pubDate>Sat, 11 Jun 2016 00:00:00 +0200</pubDate>
        </item>

        <item>
                <title>Humble beginning</title>
                <description>
&lt;h1 id=&quot;what&quot;&gt;What?&lt;/h1&gt;

&lt;p&gt;Cinode is an experimental protect, something like a sandbox for ideas.
It does/will utilize some crypto technologies to materialize new kind of
application environment. As a result of this project, I’d like to come
up with a pretty good idea on how we could create new set of apps built on
top of solid crypto base: secure by default but still relatively easy to create.&lt;/p&gt;

&lt;p&gt;This solid crypto base is the major goal here.&lt;/p&gt;

&lt;p&gt;Set of apps being a target for this base would be everything that requires
content storage: mailbox-like systems, backup storage, photo gallery, forum,
maybe even something facebook-like. What I won’t be targetting (at least at the
beginning) is everything that requires low latency communication - chats,
conferencing systems, payments etc.&lt;/p&gt;

&lt;p&gt;I don’t consider myself a good cryptographer but I know enough to not try to
invent to much of new stuff here. Instead, I’ll try to use as much of existing
technology as possible, so TLS and PGP are definitely a must here. Even if I’ll
have to get down to some lower-level stuff, it can’t be lower than some proven
crypto primitives such as AES+CBC (yeah, and I know about authenticated
encryption).&lt;/p&gt;

&lt;h1 id=&quot;why&quot;&gt;Why?&lt;/h1&gt;

&lt;p&gt;First and foremost there are some ideas I have to release from my head. They’re
there for much to long. But I also hope to add something to the crypto world
we have today.&lt;/p&gt;

&lt;p&gt;Two years ago, when Edward Snowden revealed the truth about surveillance
methods, it convinced me that there’s not enough of good crypto ever.
I still believe we’re lacking some major technologies and protection layers.&lt;/p&gt;

&lt;p&gt;What bothers me the most today is that lots of our activities jump into various
cloud systems. We lose control of the execution environments where our apps
are running. Few years ago I would have an external HDD to keep all my photos,
today I’d use some cloud service for that.&lt;/p&gt;

&lt;p&gt;And still, contrary to common attitude to “evil hackers” that present potential
threat to our security and safety, we rarely put companies into bad guy’s shoes.
What I really see is that we are biased, we are bribed.
There’s no healthy balance of trust anymore.&lt;/p&gt;

&lt;h1 id=&quot;how&quot;&gt;How?&lt;/h1&gt;

&lt;p&gt;In this blog series I’ll start describing what I came up with. This will be an
ongoing research - I’ll start describing aspects I consider to be good now.
I’ll also try to clarify new things I didn’t yet had chance to dig through.
Sometimes it will be stuff that’s not designed yet at all, sometimes those would
be things I’d like to fix or do better.&lt;/p&gt;

&lt;p&gt;Also please do not consider this experimental project as something secure for
now. Without a proper formal proof I wouldn’t consider this to be anything more
than childish play with “secret” notes. This place is here for discussion,
exchange of ideas and research.&lt;/p&gt;

&lt;p&gt;I also hope that nobady will use this stuff to exchange illegal content. So if
you came here with such intention, just leave. I don’t want this project to
be another bittorent, really great protocol which many consider a synonyme for
illegal today. We’ve spoiled to many great protocols already.&lt;/p&gt;

&lt;p&gt;I hope to put something new here once every week or two, all depends on the
amount of free time I’ll have.&lt;/p&gt;

&lt;p&gt;See you soon&lt;br /&gt;
BYO&lt;/p&gt;
</description>
                <link>http://cinode.github.io/2016/06/02/humble-beginning</link>
                <guid>http://cinode.github.io/2016/06/02/humble-beginning</guid>
                <pubDate>Thu, 02 Jun 2016 00:00:00 +0200</pubDate>
        </item>


</channel>
</rss>
