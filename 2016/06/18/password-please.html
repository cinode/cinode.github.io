

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Password please</title>
    <meta name="description" content="">
    <meta name="author" content="BYO">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!--[if lt IE 8]>
    <link rel="stylesheet" href="/assets/themes/midnight/css/ie.css">
    <![endif]-->
    <link href="/assets/themes/midnight/css/styles.css" rel="stylesheet">
    <link href="/assets/themes/midnight/css/pygment_trac.css" rel="stylesheet" type="text/css" media="all">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="/assets/themes/midnight/js/respond.js"></script>

    <!-- Le fav and touch icons -->
  <!-- Update these with your own img
    <link rel="shortcut icon" href="img/favicon.ico">
    <link rel="apple-touch-icon" href="img/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="img/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="img/apple-touch-icon-114x114.png">
  -->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  </head>

  <body>

    <div id="header">
      <nav>
        <li class="title"><h1><a href="/">Cinode dev blog</a></h1></li>
        
        
        


  
    
      
      	
      	<li><a href="/archive">Archive</a></li>
      	
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/categories">Categories</a></li>
      	
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/pages">Pages</a></li>
      	
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/tags">Tags</a></li>
      	
      
    
  



      </nav>
    </div>

    <div class="wrapper">

      <div class="content">
        

<div class="wrapper">
  <section>
    <div id="title">
      <h1>Password please</h1>
      
      <br><hr>
      <span class="credits left">Written by: <a href="">BYO</a></span>
      <span class="credits right">Last updated: 2016-06-18 00:00:00 +0200</span>
    </div>
    
<h1 id="good-keys-bad-keys">Good Keys, bad keys</h1>

<p>When using encryption, good
<a href="https://en.wikipedia.org/wiki/Key_(cryptography)">encryption keys</a> are
essential. They must be generated randomly and must contain enough entropy.
Otherwise we’ll open wide range of attacks on encrypted data.
In addition to the key, we also need
<a href="https://en.wikipedia.org/wiki/Initialization_vector">Initialization Vector</a>
(IV) which doesn’t necessarily have to be secret, but still it should be either
pseudorandom or (in case of some encryption primitives) just unique when used
together with the same key (IV is then also called a nonce).</p>

<p>We would like to apply encryption to our data blobs. Just to briefly recall,
our blobs are static, can not chagnge. Every blob has it’s own uinque name.
This name is made of cryptographically secure hash of blob’s data. This
hash also guarantees integrity of the information.</p>

<h1 id="randomize-everything">Randomize everything</h1>

<p>So, what would be the most trivial way of generating keys and IV.</p>

<p>If keys should be random, and random IVs are also a good choice, why not just
randomly generate key for every blob? For AES-256 we would have to generate
more than 2^128 blobs (due to
<a href="https://en.wikipedia.org/wiki/Birthday_problem">birthday paradox</a>) to reuse key
with probbility of ~0.5, so even if we use always the same IV and nonce-based
encryption primitives, we’re still pretty safe.</p>

<p><img src="/images/ditaa/ditaa-df68088d2039fef59a2cff9f19bca0337573fba8.png" /></p>

<p>What would be properties of such solution:</p>

<ul>
  <li>Every blob has unique key</li>
  <li>IV can be hardcoded for nonce-based encryption modes since we’re changing
key for every blob</li>
  <li>One blob encrypted twice will generate different key and different encrypted
blob</li>
</ul>

<p>All those properties may be both advantages and disadvantages.
Uniqueness of the key does guarantee high security but would require management
of such keys and won’t let us initilize the cipher once and reuse for multiple
blobs.</p>

<p>Let’s take a look at the fact that reencryption will use different key - one
benefit of this approach is that if two
people encrypt the same data, keys will be different and the encrypted blob data
will be different too. The only thing equal would be the size of blob (which
can be handled by some clever splitting and merging of data). Overall this could
look like a good solution. But it has one drawback - it does take away
deduplication which is natural in case of CAS systems. We could argue that
it’s not that needed and I agree. But in case you would be uploading your own files,
finding duplicates could would be useful. Also in case of public data or data
shared among many peole it’s better to have same keys for same blobs. This would
reduce unnecesary duplicates of data and help reducing maintenance costs - less
data to manage is always easier to manage and scale.</p>

<h1 id="derived-deterministic-keys">Derived Deterministic keys</h1>

<p>Ok, let’s try the opposite side - let’s try to assign a key to a blob in such
way that each key can be unambigously assigned to it’s blob.</p>

<p>Key must be random. One way to build pseudorandom number generator is to <a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function#Use_in_building_other_cryptographic_primitives">use
cryptographic hash</a>,
because cryptographic hash function should behave similarly to random function.
So why not just use the hash of blobs contents and use this hash as a key?
IV could be handled as before. For every blob we still use different key
so similarly to just random keys we can use predefined one for all our
cases (as long as we’re using nonce-based encryption primitives of course).</p>

<p><img src="/images/ditaa/ditaa-606f3b2a8b9e82e6a384b1e7c0f5d2f2be2e3cee.png" /></p>

<p>What properties would we get here:</p>

<ul>
  <li>Every blob has unique key</li>
  <li>IV can be hardcoded for nonce-based encryption modes since we’re changing
key for every blob</li>
  <li>Every blob of data will have exactly one key assigned and same representation
of encrypted data</li>
</ul>

<p>First two points are equal to the previous case. The third one is the
opposite so let’s take a closer look.</p>

<p>Now we are able to introduce global deduplication mechanism. If two people upload
same data to one CAS, those uploads would be identical. Such blobs would share
keys, IVs and encrypted representation. This could mean significant reduction
of space usage and may significantly reduce network costs. But it does reveal an
extra information to external observer. If the observer finds out that Alice and
Bob uploaded same blob, he would be able to assume that they have access to same
peace of unencrypted information. In case Alice does protect her environment well
and is able to fight off all attacks, attacker may also try to attack Bob. If
Bob is not that good protecting himself, the attacker may gain plain data that
was shared between Alice nad Bob.</p>

<p>Pretty nasty, right? We could try to reduce the proof of possesion here by
enforcing Alice’s environment to also store some blobs she don’t have keys to.
But if we’d like to ensure that possession of encrypted data does not mean
possession of unencrypted one, the percentage of data Alice stores and is able
to decrypt would have to be really low.</p>

<p>When such storage overkill could be practical? One case that comes to my mind
is when Alice would provide storage services to Bob and many other people and
keep backups of their encrypted blobs. Sounds like a good idea to explore in the
future, I still see many potential risks here though.</p>

<h1 id="derived-nondeterministic-keys">Derived Nondeterministic Keys</h1>

<p>There’s a simple method though to keep some benefits of deduplication and still
provide security against blob corelation between users.</p>

<p>What if we would be able to securely generate keys from blob’s contents but
those keys would be deterministic for one user only? To do that we need one more
thing - something that would represent user’s identity. One of obvious answers
here is to use assymetric keys.</p>

<p>Private key in assymetric crypto can be used to sign the message. Signing
different messages will produce different result and common low-level crypto
primitives yield same sign for the same data (they are
<a href="https://en.wikipedia.org/wiki/Pure_function">pure functions</a>).
If the sign has enough entropy
for being good key source (and it has to, otherwise we would be able to fake
signs), we can apply key derivation function on it to build the encryption key.</p>

<p><img src="/images/ditaa/ditaa-41216527d7f7b9fa2a20b1ad35cc12b25249dda1.png" /></p>

<p>This structure has few really nice properties:</p>

<ul>
  <li>Every blob has unique key</li>
  <li>IV can be hardcoded for nonce-based encryption modes since we’re changing
key for every blob</li>
  <li>Two user private keys will generate diferent encryption key for same
plaintext data</li>
  <li>Same user will generate same key and same encrypted data for same plaintext
data</li>
  <li>Encryption key is indistinguishable from random key for someone who doesn’t
have access to private user key</li>
</ul>

<p>Ok, so we see that keys will be unique but only when using same private key.
But I’d like to take a look at the last property - indistinguishibility from
random. This could be really useful in some cases. Let’s say someone publishes
some important information using this key generation method. Published blob
would first look like the one using random key. If someone would later require
a proof of authenticity of this data, the published can publish the sign of
this blob. Such sign would a) produce encryption key for the blob when put
through KDF and b) the sign would prove that the blob was generated with person
in possession of the private key.</p>

<p>Now there’s a property of deniability here. If the sign is not published, there’s
no way to connect it with the publisher. Whether it would prove itself useful,
I don’t know yet but it’s good to have such ideas for later.</p>

<h1 id="other-options">Other options</h1>

<p>We could also find few other methods to generate keys here. We could for example
generate one global encryption key for the user and for every blob use IV being
a hash of blob’s unencrypted contents. We could also build keys by hashing
blob’s content with some prefix and suffix. But in general we can divide
our methods into three groups:</p>

<table>
  <thead>
    <tr>
      <th>Method</th>
      <th>Dedupliation</th>
      <th>Good usage</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Random</td>
      <td>None</td>
      <td>Highly confidential data</td>
    </tr>
    <tr>
      <td>Derived Deterministic</td>
      <td>Global</td>
      <td>Published data</td>
    </tr>
    <tr>
      <td>Derived Nondeterministic</td>
      <td>Local</td>
      <td>Backup with deduplication</td>
    </tr>
  </tbody>
</table>

<p>I don’t see that any of different key generation schemes should be preffered.
Instead I think key generation should be adjusted to blob usage. If it would
become public at some point, key derived from contents is the best way to go.
Mixing it with private key signing does allow extra identity proof. Using purely
random keys could also be useful if you’d like to hide the fact of possession of
shared data. A robust system should enable them all.</p>

<h1 id="transparent-transport">Transparent transport</h1>

<p>You could already have noted that no matter what key encryption do we use, it
is not relevant from the point of view of CAS itself. As long as there are no
plaintext keys sent to storage system, it doesn’t have access to plaintext data.</p>

<p>Such storage is able to do some basic verification of the blob though.
If user has to upload blob along with it’s name, such blob can be rejected
if the name does not match the contents. It’s pretty nice property since even
without the knowledge of plaintext data, the storage system can do a basic
integrity verification preventing transfer of malformed data.</p>

<p>That’s it for this day. Hope to write something more soon.</p>

    <hr>
    <div style="text-align: center;">
      <span style="float: left;">
        
          <a href="/2016/06/11/static-base" title="Static base">&larr; Previous</a>
        
      </span>
      <span>
        <a href="/archive.html">Archive</a>
      </span>
      <span style="float: right;">
        
          <a href="/2016/07/26/cas-in-action" title="CAS in action">Next &rarr;</a>
        
      </span>
      </nav>
    </div>
    <div id="tags">
      <br>
      
        Tags: 
        <ul style="display: inline; padding-left: 10px;">
        
        


  
     
    	<li><a href="/tags.html#design-ref">design <span>2</span></a></li>
     
    	<li><a href="/tags.html#encryption-ref">encryption <span>1</span></a></li>
     
    	<li><a href="/tags.html#storage-ref">storage <span>4</span></a></li>
    
  



        </ul>
      
    </div>
  </section>
  <section>
    


  <div id="disqus_thread"></div>
<script type="text/javascript">
    
    var disqus_developer = 1;
    var disqus_shortname = 'cinodeblog'; // required: replace example with your forum shortname
    
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>




  </section>
</div>



      </div>

      <footer>
        <p>&copy; BYO 2016
          with help from <a href="http://jekyllbootstrap.com" target="_blank" title="The Definitive Jekyll Blogging Framework">Jekyll Bootstrap</a>
        </p>
      </footer>

    </div> <!-- /container -->
    



  </body>
</html>

