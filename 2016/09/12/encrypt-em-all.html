

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Encrypt 'em all</title>
    <meta name="description" content="Let's apply encryption to our data.">
    <meta name="author" content="BYO">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!--[if lt IE 8]>
    <link rel="stylesheet" href="/assets/themes/midnight/css/ie.css">
    <![endif]-->
    <link href="/assets/themes/midnight/css/styles.css" rel="stylesheet">
    <link href="/assets/themes/midnight/css/pygment_trac.css" rel="stylesheet" type="text/css" media="all">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="/assets/themes/midnight/js/respond.js"></script>

    <!-- Le fav and touch icons -->
  <!-- Update these with your own img
    <link rel="shortcut icon" href="img/favicon.ico">
    <link rel="apple-touch-icon" href="img/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="img/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="img/apple-touch-icon-114x114.png">
  -->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  </head>

  <body>

    <div id="header">
      <nav>
        <li class="title"><h1><a href="/">Cinode dev blog</a></h1></li>
        
        
        


  
    
      
      	
      	<li><a href="/archive">Archive</a></li>
      	
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/categories">Categories</a></li>
      	
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/pages">Pages</a></li>
      	
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/tags">Tags</a></li>
      	
      
    
  



      </nav>
    </div>

    <div class="wrapper">

      <div class="content">
        

<div class="wrapper">
  <section>
    <div id="title">
      <h1>Encrypt 'em all</h1>
      
      <br><hr>
      <span class="credits left">Written by: <a href="">BYO</a></span>
      <span class="credits right">Last updated: 2016-09-12 00:00:00 +0200</span>
    </div>
    
<h1 id="another-step-in-the-implementation-journey">Another step in the implementation journey</h1>

<p>This time we’ll take a look at <a href="https://github.com/cinode/go/tree/v2016-09-12/blenc">the implementation of blob encryption layer</a>. Just before we start I give you one puzzle to solve - there’s one serious security flow in   current implementation. I wonder if you’ll be able to spot it. I plan to  show and fix it in the next post.</p>

<h1 id="general-idea">General idea</h1>

<p>Blob encryption will be another layer of code, separate from the fist one - datastore. To keep it isolated, it will have it’s own namespace: blenc. (Yup, I was too lazy to come up with a better name ;))</p>

<p>What would be the purpose of this layer? It will handle three major operations:</p>

<ol>
  <li>Encrypt data</li>
  <li>Decrypt data</li>
  <li>Generate encryption parameters (keys, ciphers, IVs)</li>
</ol>

<p>Encryption and decryption is pretty obvious here: on the one end of the layer we’ll be talking in plain text, on the other side we’ll only see the encrypted stuff.</p>

<p>This layer also handles selection of ciphers and their parameters. Since we’re handling both cipher selection and encryption parameters in a code close to each other, it will be easier to match them correctly and avoid subtle bugs leading to security disasters.</p>

<h1 id="ciphers">Ciphers</h1>

<p>I decided to use stream ciphers. It simplifies implementation since no secure padding is needed to round data to block size. Also, the size of encrypted blob and the plaintext one is the same. This is both good and bad - good since we’re not occupying more space due to encryption, bad because it reveals the size of the original data. It’s not yet a security flow but something to think about in layers on higher levels where we can handle the issue much more efficiently.</p>

<p>Currently there are two well-known ciphers supported in the code: <a href="https://github.com/cinode/go/blob/v2016-09-12/blenc/cipher_factory.go#L69">AES256-CTR</a> and <a href="https://github.com/cinode/go/blob/v2016-09-12/blenc/cipher_factory.go#L80">ChaCha20</a>. <a href="https://pl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> was obvious for it’s wide adoption and years of cryptoanalysis. Used with CTR mode it creates really strong stream cipher. <a href="https://en.wikipedia.org/wiki/Salsa20#ChaCha_variant">ChaCha20</a> turns out to be good choice too. It’s strength is in it’s great performance (especially on mobiles where there’s no hardware aceleration for AES). If you wonder whether anybody you know is using it in production now, take a look at <a href="https://blog.cloudflare.com/do-the-chacha-better-mobile-performance-with-cryptography/">Cloudflare</a> and <a href="https://security.googleblog.com/2014/04/speeding-up-and-strengthening-https.html">Google</a>.</p>

<p>I have selected <a href="https://github.com/cinode/go/blob/v2016-09-12/blenc/cipher_factory.go#L22">ChaCha20</a> to be the default encryption cipher. I believe it has a great potential and will become more widely adopted in the world of smaller devices (IoT is just around the corner). The <a href="https://github.com/yawning/chacha20">implementation</a> you can find in go is also very fast, easily outperforming AES if no hardware acceleration is present.</p>

<h1 id="keygens">KeyGens</h1>

<p>Key generation was a bit tricky. First I implemented trivial key generator that always returns <a href="https://github.com/cinode/go/blob/v2016-09-12/blenc/keygenerator_contant.go">predefined key data</a>. Because the same IV is used for every blob, this implementation is really unsafe and fundamentally broken - it will generate the same key+IV pairs for many blobs. Because of that, the implementation is internal to the module and I use it only for testing purposes.</p>

<p>Another simple implementation was a <a href="https://github.com/cinode/go/blob/v2016-09-12/blenc/keygenerator_random.go">random key generator</a>. It’s almost as simple as the constant-key one but it does provide high quality random keys. As long as we’re not relying on data deduplication, this method is the best way to generate keys.</p>

<p>The last key generator I implemented in this iteration was a <a href="https://github.com/cinode/go/blob/v2016-09-12/blenc/keygenerator_contents.go">contents-based key generator</a>. It’s purpose is to create key from the hash of blob’s contents. It is secure because it will generate different keys for different blobs - that requirement is guaranteed by collision resistance property of cryptographic hash function. This generator is the only one so far which requires reading whole data bufer (to calculate hash) before we start encrypting it. Data source is given as only io.Reader interface - meaning we can not seek back. This forces us to store the data in some kind of temporary buffer - and this was the hardest part to implement for this key generation scheme.</p>

<h1 id="tricky-buffer">Tricky buffer</h1>

<p>There are few naïve approaches to temporary buffer. First is to store everything in memory. Of course this would limit the size of blobs we could handle. Another idea is to store the data in some temporary file and then read id back. It sounds like a much better approach and has indeed been used in my implementation but if implemented incorrectly it would lead to serious security flows.</p>

<p>First of all, the data stored in temporary files could accidentally be made readable by other users on the same system revealing plaintext data to them. Second, this data would end up being written down onto local filesystem and HDD - secure erasure of data is not a trivial problem and in case of flash-based memory may not be possible at all. That’s why in my implementation I’m storing the data in an encrypted form. The key is random and is kept inside memory only. Losing the key means losing access to the plaintext which is exactly what we need. There’s a large encryption overhead though (3x: encrypt data when storing to temporary file, decrypt data when reading from temporary file and do the final encryption) but I believe it’s worth it. The implementation of secure temporary buffer is <a href="https://github.com/cinode/go/blob/v2016-09-12/blenc/secure_temp_buffer.go">here</a>.</p>

<p>Even if we store data encrypted on a temporary location we may still fail to protect against tempering of encrypted data - a common mistake if data integrity is not checked. To overcome this issue in my implementation, I created a <a href="https://github.com/cinode/go/blob/v2016-09-12/blenc/reader_hash_validator.go">reader validating hash of it’s data</a>. It’s purpose is to check if the data read through it has given hash value and reject the stream if it’s not. Since we already have the hash of the original, unencrypted data (it will be used to generate encryption key), we can use it to check the integrity when we read back from temporary buffer.</p>

<h1 id="not-all-done-yet">Not all done yet</h1>

<p>I didn’t implement everything in this layer yet. On the list of things left to do is the key generator using cyprographic signs and http interface. I leave those for some future updates - I believe enough has been implemented to move on to the next layer that would create a solid base for applications hosted in Cinode.</p>

<p>See you at the next post.</p>

    <hr>
    <div style="text-align: center;">
      <span style="float: left;">
        
          <a href="/2016/08/08/refactoring-mistakes" title="Refactoring mistakes">&larr; Previous</a>
        
      </span>
      <span>
        <a href="/archive.html">Archive</a>
      </span>
      <span style="float: right;">
        
          <a href="/2016/09/27/trust-noone" title="Trust noone">Next &rarr;</a>
        
      </span>
      </nav>
    </div>
    <div id="tags">
      <br>
      
        Tags: 
        <ul style="display: inline; padding-left: 10px;">
        
        


  
     
    	<li><a href="/tags.html#golang-ref">golang <span>4</span></a></li>
     
    	<li><a href="/tags.html#programming-ref">programming <span>4</span></a></li>
     
    	<li><a href="/tags.html#encryption-ref">encryption <span>3</span></a></li>
     
    	<li><a href="/tags.html#prototype-ref">prototype <span>4</span></a></li>
    
  



        </ul>
      
    </div>
  </section>
  <section>
    


  <div id="disqus_thread"></div>
<script type="text/javascript">
    
    var disqus_developer = 1;
    var disqus_shortname = 'cinodeblog'; // required: replace example with your forum shortname
    
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>




  </section>
</div>



      </div>

      <footer>
        <p>&copy; BYO 2016
          with help from <a href="http://jekyllbootstrap.com" target="_blank" title="The Definitive Jekyll Blogging Framework">Jekyll Bootstrap</a>
        </p>
      </footer>

    </div> <!-- /container -->
    



  </body>
</html>

