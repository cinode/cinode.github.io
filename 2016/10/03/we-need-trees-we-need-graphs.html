

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>We need trees, we need graphs</title>
    <meta name="description" content="Today we'll think about extending our flag blob structure into more flexible structure with connections between blobs.">
    <meta name="author" content="BYO">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!--[if lt IE 8]>
    <link rel="stylesheet" href="/assets/themes/midnight/css/ie.css">
    <![endif]-->
    <link href="/assets/themes/midnight/css/styles.css" rel="stylesheet">
    <link href="/assets/themes/midnight/css/pygment_trac.css" rel="stylesheet" type="text/css" media="all">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="/assets/themes/midnight/js/respond.js"></script>

    <!-- Le fav and touch icons -->
  <!-- Update these with your own img
    <link rel="shortcut icon" href="img/favicon.ico">
    <link rel="apple-touch-icon" href="img/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="img/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="img/apple-touch-icon-114x114.png">
  -->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  </head>

  <body>

    <div id="header">
      <nav>
        <li class="title"><h1><a href="/">Cinode dev blog</a></h1></li>
        
        
        


  
    
      
      	
      	<li><a href="/archive">Archive</a></li>
      	
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/categories">Categories</a></li>
      	
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/pages">Pages</a></li>
      	
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/tags">Tags</a></li>
      	
      
    
  



      </nav>
    </div>

    <div class="wrapper">

      <div class="content">
        

<div class="wrapper">
  <section>
    <div id="title">
      <h1>We need trees, we need graphs</h1>
      
      <br><hr>
      <span class="credits left">Written by: <a href="">BYO</a></span>
      <span class="credits right">Last updated: 2016-10-03 00:00:00 +0200</span>
    </div>
    
<h1 id="extending-flat-blob-space">Extending flat blob space</h1>

<p>Standard CAS system gives us a flat namespace. There’s no structure of data nor relationship between blobs. Although this could be enough for some range of applications, better tools to organize data would definitely help here. First we would simplify code of applications, second we may need such structures to efficiently express data access authorization patterns. That’s why we have to go beyond a flat structure and introduce some data connections.</p>

<p>A natural improvement is to build a tree - similarly to what happens with files in a filesystem. This can be easily achieved in a flat structure by adding directory blobs. The purpose of blobs of that type is to list other ones and give them useful names and other metadata. Once we have directories, we can easily form trees by simply putting some directories into other ones.</p>

<p>Naturally we can imagine that such connections through directory could easily form a structure of a tree, but this is not the only form we can build. Just as in most modern local filesystems, we can implement links which extend beyond a tree and form a graph. Two directories can point to the same blob.</p>

<p><img src="/images/ditaa/ditaa-6edf75e544803d2e7830178ed1c91776754cdd78.png" /></p>

<p>In the example above, <code>Blob6</code> can be reached through paths <code>/Name6</code> and <code>/Name3/Name5</code>.</p>

<p>Although it looks like the graph we can form with our blob should be acyclic, this should not be relied on. In a situation where we don’t have encryption, cyclic graph would be almost impossible to calculate - contents of directory blobs would indirectly depend on their own hashes so cryptographic hash function would have to expose some special properties allowing us to create such cycle. This though would be against properties of strong cryptographic hash functions.</p>

<p>As soon as we introduce encrypted blobs, the case may be more complicated. Even though the contents of a directory blob would be dependent on it’s hash, we can still tweak the encryption key. It could be likely that the contents of encrypted blob (that’s what we would use to get the hash from) could be tweaked through encryption key so that it matches expected result. A correct proof would definitely help here (maybe in some future blog post) but right now I’d say we would have to assume those graphs could be cyclic too.</p>

<p>Later we’ll also introduce something called dynamic links which would let us trivially add cycles. What this means is that applications that would like to trace the graph would have to add some protection against recursivity level to prevent hangs or stack overflows.</p>

<h1 id="metadata">Metadata</h1>

<p>In addition to filename, given blob may have many more properties. A good example of those would be: blob’s mime type, creation date, author, expiry date. Since the list of properties could be dynamically adjusted for every blob, it’s best to keep them in a dynamic map per each object.</p>

<p>There’s one special property needed for every blob if they are encrypted - <code>key info</code>. This data would have to contain enough information to create encryption key for given blob. A natural location for such property would be blob’s metadata.</p>

<h1 id="hidden-keys">Hidden keys</h1>

<p>Since <code>key info</code> is very likely to be different for every blob, it could be embedded within directory listing as object’s metadata. The most straightforward way to store it is to put the raw key value straight into the info. Only those who have access to directory’s listing will get such keys so those blob keys would be secured by directory’s own encryption. This approach could be fine in many cases but one must realize that the root directory would then become primary security gate for the whole graph structure. If you know key and blob name of such root, you gain access to everything it directly or indirectly points to.</p>

<p>If a contents of such root directory blob is accidentially published or shared with an unauthorized recipient, there’s no way to easily revert it. User could easily and quickly trace the whole accessible graph and gain access to data of every leaf blob.</p>

<h1 id="keys-with-a-lock">Keys with a lock</h1>

<p>Instead of full key in <code>key info</code> we could store other information that does not reveal the key itself but can be used to build one. A simple solution is to store id of a key instead of it’s value. User would have to possess some keys database before blob encryption and decryption. If the key with matching id would not be found inside such db, that user wouldn’t have access to the blob.</p>

<p>Another solution is to store the key in an encrypted form. In order to get the key for that particular blob, we have to take this encrypted form, get some other key (which could be directory’s key for example) and then decrypt blob’s key to it’s raw form. We can even apply a little recursion here - key to decrypt blob’s key could actually be encrypted with another key too, that key can be protected by another key and so on:</p>

<p><img src="/images/ditaa/ditaa-fcce9fd661071500e5151d9784117e8e9fb0fc6d.png" /></p>

<p>Such key chain can be found in <a href="https://www.net.t-labs.tu-berlin.de/~stefan/srds06.pdf">Cryptree structure</a> and is called cryptographic link. What this basically means is that if you know <code>Key 1</code> then you can extract <code>Key 2</code>, if you know <code>Key 2</code>, then you can extract <code>Key 3</code> and so on. Knowing only <code>Key 3</code> won’t reveal <code>Key 1</code> or <code>Key 2</code> but will give access to <code>Key 4</code> and <code>Key 5</code>.</p>

<p>Simple straight chain can also be extended allowing multiple paths to one key:</p>

<p><img src="/images/ditaa/ditaa-b681fb62e7c895e9167f16c31a15560ba4af28b3.png" /></p>

<p>This is the structure I’d like to explore a bit.</p>

<h1 id="friend-of-friends">Friend of friends</h1>

<p>You may recall that many social platforms expose you an information up to some level of connectivity. Some information is viewable by our “friends”, some is seen by “friends of our friends”. Let’s try to express this idea in a more cryptographic approach.</p>

<p>Our goal is to have different access rights to data depending on the distance to the source. The distance can be modelled within directory blobs and access to certain <code>key info</code> will be equal to having read grant on given information:</p>

<p><img src="/images/ditaa/ditaa-4cb54d39c99052e33b4c7a948213a9b4b9960552.png" /></p>

<p>In this example, each user generates 3 master keys assigned to his directory:</p>

<ul>
  <li><code>Key lvl1</code> - this is the key that gives access to all private data that should be accessible only by the owner. Since this key links to lvl2 and lvl3, user having it will have access to information on all other levels.</li>
  <li><code>Key lvl2</code> - this is the key that’s exposed to direct frinds of the user and protects blobs that contain information visible to friends. It also links to lvl3 key.</li>
  <li><code>Key lvl3</code> - this is the key that protects information visible by friends of friends.</li>
</ul>

<p>In order for this to work, first and the most important rule is that we must keep <code>Key lvl1</code> for ourselves - that’s to protect the information that’s private.</p>

<p><code>Key lvl2</code> must be shared with our friends. Friend relationships are most likely associated with some communication channel between users so it should be utilized to exchange <code>Key lvl2</code> information.</p>

<p>Giving keys to friends of our friends is a bit tricky though. We don’t have access nor we manage friend relationship of our friends so granting lvl3 key must be handled through some indirection we can controll. In order to see a solution to this problem, let’s picture multiple users and their keys (I’ve removed unimportant parts):</p>

<p><img src="/images/ditaa/ditaa-1451b662bfbc52f472e05705e0b835fb18e552ef.png" /></p>

<p>In the example above, <code>User1</code> represents someone who’s willing to share his data. <code>User2</code> is a direct friend of <code>User1</code>. <code>User3</code> is a direct friend of <code>User2</code> but is not a direct friend of <code>User1</code>. Our goal is to give access to <code>Key lvl3</code> of <code>User1</code> to <code>User3</code>.</p>

<p>Since <code>User3</code> is a friend of <code>User2</code>, we know that <code>User3</code> knows <code>Key lvl2</code> of <code>User2</code>. We can exploit that property and add extra blob in  directory of <code>User2</code> that will contain all <code>lvl3 keys</code> of his friends. That way, everyone who has access to <code>Key lvl2</code> of <code>User2</code> will gain access to <code>Key lvl3</code> of all his friends.</p>

<p>This of course requires <code>User2</code> to manage this extra blob with keys. But this should be no more complicated than establishing friend relationship itself. I can bet that the final implementation will be much more complicated and will include some assymetric crypto, but I hope it shows generic idea.</p>

<p>This is just an example of how powerful directory structures could be. It does require clever key management and some extra cryptographic primitives but it prooves usefulnes of such structure. We could probably come up with a lot more examples like this. Nevertheless, I wouldn’t be myself if I wouldn’t first bring some problems that can easily arise with directory blobs.</p>

<h1 id="fat-dir">Fat dir</h1>

<p>As long as directory is relatively small, operations on it should be simple. Whenever something inside such directory changes, we just update it’s contents, reencrypt it and propagate the change up in the directory chain.</p>

<p>But let’s imagine a directory containing millions of entries. I can bet that real-world applications would very quickly generate them. We won’t be able to efficiently handle such amount of data.</p>

<p>What we can do is to split one blob into many smaller ones. One approach is to create n data partitions and assign entries by using hash of blob’s name. This approach should be good enough to evenly split one huge directory into multiple smaller partial ones plus one blob for the hash map itself.</p>

<p><img src="/images/ditaa/ditaa-7b55f66d85f9332c881e8eb285c6c9aa020fa43e.png" /></p>

<p>This solution will be problematic if we’d like to get ordered subset of entries - when using hash to partition data, search would have to be performed in all partial blobs and then merged together. We could also use different trick. Let’s take all entries, sort then and then split this ordered list into similarly sized subsets. The blob for the directory would then contain information about starting entry, ending entry and link to sub-directory blob for every partition.</p>

<p><img src="/images/ditaa/ditaa-bb1eb47502aa6452be754649a14472317b2e2d10.png" /></p>

<p>There could be some non-trivial problems to solve in such structure during updade - we’d have to move entries between partial blobs, dynamically split and merge to keep the balance at an acceptable level. However if we could afford to build such directory once in a while and use it for read-only operations,
performance gain could be significant.</p>

<p>That’s it for this post. I’m aware that I just scratched the surface and oversimplified real problem in many cases. What I wanted to show is how we could build complex structures by using simple blobs and various key management techniques. I hope you have a generic feeling of how powerful such system could be. One important thing to note here is that we’re still relying on simple CAS storage below which means that the whole solution can use storage independent from any particular vendor, can be stored in a secure way without revealing information to 3rd parties and can scale well.</p>

<h1 id="are-we-done-yet-nope">Are we done yet? Nope.</h1>

<p>We still are not yet ready to build fully functional applications with what we have so far. Although blobs started forming nice data structures, we’re lacking some attachment points, links to this structure. And similarly to how branch names in git let us efficiently colaborate with other people, we need few extra primitives that would let us do the same in Cinode.</p>

<p>But before I’ll dig into that problem, let’s first create proof-of-concept application with things discussed so far.</p>

<p>See you soon.</p>

    <hr>
    <div style="text-align: center;">
      <span style="float: left;">
        
          <a href="/2016/09/27/trust-noone" title="Trust noone">&larr; Previous</a>
        
      </span>
      <span>
        <a href="/archive.html">Archive</a>
      </span>
      <span style="float: right;">
        
          <a>Next &rarr;</a>
        
      </span>
      </nav>
    </div>
    <div id="tags">
      <br>
      
        Tags: 
        <ul style="display: inline; padding-left: 10px;">
        
        


  
     
    	<li><a href="/tags.html#design-ref">design <span>3</span></a></li>
    
  



        </ul>
      
    </div>
  </section>
  <section>
    


  <div id="disqus_thread"></div>
<script type="text/javascript">
    
    var disqus_developer = 1;
    var disqus_shortname = 'cinodeblog'; // required: replace example with your forum shortname
    
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>




  </section>
</div>



      </div>

      <footer>
        <p>&copy; BYO 2016
          with help from <a href="http://jekyllbootstrap.com" target="_blank" title="The Definitive Jekyll Blogging Framework">Jekyll Bootstrap</a>
        </p>
      </footer>

    </div> <!-- /container -->
    



  </body>
</html>

